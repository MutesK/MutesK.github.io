<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mute의 개발 블로그</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Mutesk.github.io/"/>
  <updated>2018-03-31T05:24:05.087Z</updated>
  <id>https://Mutesk.github.io/</id>
  
  <author>
    <name>JunMin Kim, j0803@naver.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++에서의 클래스 크기, sizeof</title>
    <link href="https://Mutesk.github.io/2018/03/31/cpp-class-size/"/>
    <id>https://Mutesk.github.io/2018/03/31/cpp-class-size/</id>
    <published>2018-03-31T04:56:02.000Z</published>
    <updated>2018-03-31T05:24:05.087Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sizeof 연산자는 컴파일러가 컴파일할때 크기를 인식한다. 그 크기를 상수로 바꾼다.<br>포인터를 동적할당한뒤 sizeof을 하면 배열을 sizeof한것과 달리 포인터의 크기만 나오게 된다.</p></blockquote><h1>클래스의 크기</h1><blockquote><p>컴파일러가 빈 클래스를 보면, 더미 맴버를 안에 넣어서 생성하게 된다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">becomes:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">char</span> __dummy; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>빈 껍데기를 상속받은 클래스도 base class optimization을 수행하는 대부분의 컴파일러에서는 1 바이트가 된다.</p></blockquote><h2>Case 1. Empty Class 크기</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temp Size = 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span>  // <span class="title">Size</span> = 1</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CBase()&#123;&#125;</span><br><span class="line">~CBase() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSub</span> :</span> <span class="keyword">public</span> CBase  <span class="comment">// Size = 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CSub()&#123;&#125;</span><br><span class="line">~CSub()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>Case 2. 가상함수가 있는 클래스</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVBase</span>  // <span class="title">Size</span> = 4</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CVBase() &#123;&#125;</span><br><span class="line">~CVBase() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVSub1</span> :</span> <span class="keyword">public</span> CVBase <span class="comment">// Size = 4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CVSub1()&#123;&#125;</span><br><span class="line">~CVSub1()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVSub2</span> :</span> <span class="keyword">public</span> CVBase <span class="comment">// Size = 4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CVSub2()&#123;&#125;</span><br><span class="line">~CVSub2()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVSub3</span> :</span> <span class="keyword">public</span> CVBase <span class="comment">// Size = 4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CVSub3() &#123;&#125;</span><br><span class="line">~CVSub3()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>Case 3. Static 맴버 변수가 있는 클래스</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSObject</span>  // <span class="title">Size</span> = 1</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSVObject</span> :</span> <span class="keyword">public</span> CSObject  <span class="comment">// Size =  12</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> _a;</span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>빈 클래스인 경우, 메모리 상에서 Instance 들이 Array에서 Empty Class의 Instance를 구분하기 위해서 최소한의 크기인 1byte를 할당.<br>Class의 Instance는 Heap or Stack 어딘가에 자리를 잡을수 있게 되고, Class Instance를 구분할수 있게 주소를 받게된다.</p></blockquote><blockquote><p>가상함수가 사용된다면 가상함수테이블를 가르키는 포인터가 클래스 내부안에 들어가게 되므로, 4 바이트 할당된다.<br>static 변수는 Class안에 있는것 처럼보이지만, 해당 클래스에 하나만 생성되고 모든 인스턴스에서 공동으로 접근가능하므로,<br>실제로는 안에 있지가 않다.</p></blockquote><blockquote><p>클래스와 구조체는 Default Access의 차이밖에 없다. 즉, 맴버변수에 따라서, Padding이 일어나는데, 가장 큰변수를 타입으로 저장하게 된다.<br>위의 예제는 int가 가장크므로 <code>sizeof(int) * 3</code>과 같게된다.</p></blockquote><h1>배열, 포인터의 전달과 크기</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SIZE_p</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SIZE_a</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(Array)); <span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SIZE_p(Array)); <span class="comment">// Pointer 명시적 전달 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SIZE_a(Array)); <span class="comment">// Pointer 암묵적 전달 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;sizeof 연산자는 컴파일러가 컴파일할때 크기를 인식한다. 그 크기를 상수로 바꾼다.&lt;br&gt;
포인터를 동적할당한뒤 sizeof을 하면 배열을 sizeof한것과 달리 포인터의 크기만 나오게 된다.&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ Chapter2</title>
    <link href="https://Mutesk.github.io/2018/03/30/Effective-C-Chapter-2/"/>
    <id>https://Mutesk.github.io/2018/03/30/Effective-C-Chapter-2/</id>
    <published>2018-03-30T03:27:31.000Z</published>
    <updated>2018-03-30T03:34:26.881Z</updated>
    
    <content type="html"><![CDATA[<h1>Item 5. C++가 은근슬쩍 만들어서 호출하는 함수에 대해 촉각을 세우자.</h1><blockquote><p>복사 생성자, 복사 대입 생성자, 기본생성, 소멸자을 기본으로 만들고 전부 public 접근 지정자이며 inline 함수이다.</p></blockquote><p>기본 생성과 소멸자인경우, 컴파일러에게 코드를 깔수 있는 자리를 마련해준다.<br>만약 상속관계에서의 소멸자인경우, 상속한 클래스가 가상소멸자 선언을 안되어 있다면 비가상 소멸자로 만들어진다.<br>복사생성자와 복사 대입생성자가 기본으로 생성되는 경우에는, 원본 객체의 비정적 데이터를 사본으로 그저 복사할뿐이다. (얇은 복사)</p><p><strong><em>결정적으로 복사 대입 연산자를 private로 선언한 기본 클래스로부터 파생된 클래스인 경우, 암시적 복사 대입 연산자를 가질수 없다.</em></strong></p><p>파생 클래스에 대해 컴파일러가 만들어주는 복사 대입 연산자는 기본 클래스 부분을 맡도록 되어 있도록 되어 있긴하지만, 이렇게 하더라도 파생클래스에서 호출할 권한이 없는 맴버 함수는 암시적 복사 대입 연산자가 어떻게 호출할수 없다.</p><blockquote><p>컴파일러가 파생클래스의 생성한 복사 함수(복사생성, 복사 대입)는 기본 클래스의 대응 버전을 호출하도록 되어 있는다는 점!</p></blockquote><h1>Item 6. 컴파일러가 만들어낸 함수가 필요없다면 확실히 이들의 사용을 금해버리자.</h1><blockquote><p>컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 맴버 함수를 private로 선언한뒤 구현을 하지않은채로 두면된다.<br>또는 Uncopyable라는 클래스를 만들고 private 로 상속시키는 것도 방법</p></blockquote><h1>Item 7. 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자.</h1><blockquote><p>문제는 포인터가 가르키는 객체의 타입에 맞춰서 삭제된다는 점인데, 비가상 소멸자가 들어 있다면 파생 클래스 객체가 삭제될때,<br>프로그램의 동작은 미정의 사항이라고 되어 있다. 대게 그 객체의 파생 클래스 부분이 소멸되지 않게 된다. // 소멸자를 호출할때, 기준의 포인터 형태가 중요</p></blockquote><p><strong><em>가상 소멸자를 선언하는 것은 그 클래스에 가상함수가 하나라도 들어있는 경우에만 한정하자.</em></strong></p><p>기본클래스로 설계되지 않았거나 다형성을 갖도록 설계되지않은 클래스에는 가상소멸자를 선언하지 말아야 됩니다. - 파생 클래스의 소멸자가 호출되지 않게됩니다.</p><h1>Item 8. 예외가 소멸자를 떠나지 못하도록 붙들어 놓자.</h1><blockquote><p>만약 vector가 있을때, 벡터의 타입은 어떤 클래스의 인스턴스인 상황에서, 첫번째 것을 소멸시키는 도중에 예외가 발생하였고, 다음 나머지 객체들의 소멸을 위해 소멸자를 호출하고 이때 또 예외가 나온다면 활성화된 예외가 2개 이상인 상황이면, C++에서 감당하기 버거워진다.</p></blockquote><p><strong>걱정처리를 피하는 방법 1 프로그램을 바로 끝낸다.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">~~~</span><br><span class="line">&#125; <span class="keyword">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// close 로그 작성</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>걱정거리를 피하는 방법2. 예외를 삼겨버린다.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">~~~</span><br><span class="line">&#125; <span class="keyword">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// close 로그 작성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예외 삼키기는 그리 좋진 않다. 그저 로그만 알려줄뿐이다. 2번째 선택이 빛을 발하기 위해서는 예외를 무시하더라도 신뢰성있게 실행을 지속할수 있어야만 된다.<br>더 좋은 방법으로는, 예외가 소멸자가 아닌 다른 함수에서 비롯된 것이어야 된다. 소멸자는 프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문에<br>close함수를 따로만들어서 호출시킨다면, 사용자에게 에러를 처리할수 있는 기회를 주게된다.</p><h1>Item 9. 객체 생성 및 소멸 과정에서는 가상함수를 호출하지 말자.</h1><p>호출결과가 원하는대로 돌아가지 않기 때문.<br>상속관계에서의 생성자 호출은 기본 클래스의 생성자 다음에 파생 클래스의 생성자가 호출되는데, 기본 클래스 생성자가 돌아가고 있을때 어쩌다가 가상함수를 호출하게되고,<br>파생 클래스 쪽을 건들이게 된다면, 아직 파생클래스는 초기화되지 않은 상황이라 어떻게 될지 모르는 상황이 온다.</p><p>파생 클래스 객체의 기본 클래스 부분이 생성되는 동안, 그 객체의 타입은 바로 기본 클래스.<br>호출되는 가상 함수는 모두 기본 클래스의 것으로 resolve(결정)될 뿐만 아니라, 런타임 타입 정보를 사용하는 언어 요소를 사용한다고 해도,<br>이순간에는 기본 클래스 타입으로 취급된다.</p><h1>Item 10. 대입 연산자는 *this 참조자를 반환하게 하자.</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Item 11. operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자.</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>수많이 대입이 일어난다면, 처리가 느려진다. 이때의 기법이 Copy and Swap.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Widget Temp(rhs); <span class="comment">// rhs에 대해 사본 -&gt; 복사생성자</span></span><br><span class="line">swap(temp); <span class="comment">// *this와 temp을 맞바꾼다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 개 이상의 객체 대해 동작하는 함수가 있다면 이 함수에 넘겨지는 객체들이 사실<br>같은 객체인지 확인!</p><h1>Item 12. 객체의 모든 부분을 빠짐없이 복사하자.</h1><blockquote><p>객체 복사 함수는 주어진 객체의 모든 데이터 맴버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사한다.</p></blockquote><p>클래스의 복사 함수 2개 를 구현할때, 한쪽을 이용해서 다른쪽을 구현하려고 하지마라.<br>그 대신 공통된 동작을 제 3의 함수에 분리해 놓고 양쪽에서 호출해서 해결.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Item 5. C++가 은근슬쩍 만들어서 호출하는 함수에 대해 촉각을 세우자.&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;복사 생성자, 복사 대입 생성자, 기본생성, 소멸자을 기본으로 만들고 전부 public 접근 지정자이며 inline 함수이다.&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Vector 컨테이너, deque 컨테이너, list 컨테이너</title>
    <link href="https://Mutesk.github.io/2018/03/30/STL-Chatper-2-2/"/>
    <id>https://Mutesk.github.io/2018/03/30/STL-Chatper-2-2/</id>
    <published>2018-03-29T22:46:10.452Z</published>
    <updated>2018-03-30T00:40:23.736Z</updated>
    
    <content type="html"><![CDATA[<h1>벡터 컨테이너</h1><blockquote><p>타입 T를 원소를 갖는 컨테이너, Array 컨테이너와 같지만, <strong><em>더 많은 원소를 수용할수 있도록 크기가 자동으로 커진다.</em></strong></p></blockquote><h2>벡터 컨테이너 생성</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line"><span class="comment">// 원소가 하나도 없고, 원소를 위해 할당된 공간이 없는 상태.</span></span><br><span class="line"><span class="comment">// 첫번재 데이터를 추가할때 자동으로 할당된다.</span></span><br><span class="line"></span><br><span class="line">values.reserve(<span class="number">20</span>); </span><br><span class="line"><span class="comment">// 20개까지 저장할수 있는 메모리 할당</span></span><br></pre></td></tr></table></figure><blockquote><p><code>reserve()</code> 호출시 할당된 메모리가 증가했다면, 시작 반복자, 끝 반복자 처럼 이미 생성한 반복자들은 무효화 되므로, 반복자는 다시 생성해야된다.</p><p>컨테이너를 늘리는 과정에서 기존 원소들이 새로운 메모리 위치로 복사되거나 이동될수 있다.<br>동적으로 컨테이너 크기가 확장 축소가 되지만, Reallocation 비용이 너무 크다.<br>Capacity 확장하면서 메모리 위치가 복사되거나, 이동될때, 그만큼 복사생성후, 기존 원소들은  파괴해야된다.</p></blockquote><h2>벡터 컨테이너의 원소 삭제</h2><blockquote><p><code>auto iter = data.erase(std::begin(data) + 1)</code>은 두번째 원소를 삭제하는것이고, iter는 삭제한 원소의 다음을 가르키게된다. <code>remove()</code> 함수는 범위에서 지정한 값과 일치하는 원소들을 제거하난데, 제거 한만큼 뒤의 인덱스를 옮겨야되는 단점으로 인해 삽입, 삭제가 빈번하면 성능이 좋지않다.</p></blockquote><h2>벡터 컨테이너 특징</h2><ol><li>중간에 데이터 삽입, 삭제가 용이하지않음.</li><li>랜덤 접근이 가능하다.</li></ol><h2>벡터는 언제 사용해야 효율적?</h2><ol><li>저장할 데이터 수가 가변적</li><li>중간에 데이터 삽입이나 삭제가 없다 -&gt; 하지만 표본데이터가 적을때는 괜찮다.</li><li>저장할 데이터 갯수가 적거나 많은 경우, 빈번하게 검색하지 않는 경우</li><li>데이터 접근이 랜덤으로 이룰때</li></ol><hr><h1>Deque 컨테이너</h1><blockquote><p>양쪽을 삽입 및 삭제가 가능한 컨테이너이다.  스택과 큐의 장점을 모은것이라고 봐도 된다.</p><p>벡터는 뒤에서만 삽입 삭제를 해야 성능이 좋지만 순차열의 시작이나 끝에 객체들을 효율적으로 추가하거나 삭제할수 있다는 점에서는 벡터보단 낫다.</p><p>DB의 트랜젝션 처리나 슈퍼마켓에서 계산대 열을 시뮬레이션을 할때는 deque가 좋다.</p></blockquote><h2>Deque 컨테이너 특징</h2><ol><li>크기가 가변적</li><li>앞과 뒤 삽입과 삭제가 좋음.</li><li>중간에 데이터 삽입, 삭제가 용이하지 않음.</li><li>랜덤 접근이 가능하다.</li></ol><h2>Deque는 언제 사용해야 효율적?</h2><ol><li>앞과 뒤에서만 삽입, 삭제를 한다.</li><li>저장할 데이터 갯수가 가변적이다.</li><li>검색을 거의 하지않는다.</li><li>데이터 접근을 랜덤하게 할때</li></ol><p><em>Deque와 Vector를 비교할때, deque는 앞과 뒤에서 삽입 삭제 성능이 vector 보다 좋고, 나머지 기능은 vector보다 성능이 좋지 않다.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter first name seperated by space. Enter Ctrl + Z on a new line to end:\n"</span>;</span><br><span class="line">copy(<span class="built_in">std</span>::istream_iterator &lt;<span class="built_in">string</span>&gt; &#123;<span class="built_in">std</span>::<span class="built_in">cin</span>&#125;, <span class="built_in">std</span>::istream_iterator &lt;<span class="built_in">string</span>&gt; &#123;&#125;, <span class="built_in">std</span>::front_inserter(names));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nIn reverse order , the names you entered are: \n"</span>;</span><br><span class="line">copy(begin(names), end(names), <span class="built_in">std</span>::ostream_iterator&lt;<span class="built_in">string</span>&gt; &#123;<span class="built_in">cout</span>, <span class="string">" "</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>List 컨테이너</h1><blockquote><p>벡터나 덱 컨테이너에 비교해서 순차열의 어느 위치라도 상수 시간에 원소 삽입, 삭제가 가능하고, 중간위치에도 삽입, 삭제가 빠르다는 장점이 있다.</p><p>하지만 순차열에서 특정 위치에 있는 원소에 바로 접근할수가 없다. <code>auto iter = list.begin() + 4</code> 같은 연산은 랜덤엑세스가 가능해야 사용가능하다.</p><p>위의 연산을 하고자한다면 그만큼 루프를 돌거나 <code>advance()</code> 전역 함수를 이용해서 반복자를 증가시킨다.</p></blockquote><h2>컨테이너 생성</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; word;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원소 지정 생성</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; word&#123;<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원소 지정하고 값을 채워서 생성</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; values(<span class="number">50</span>, <span class="number">3.141592</span>); <span class="comment">// 만약 초기화 리스트를 사용했다면 50, 3.141592 두개의 값만 가진다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 리스트는 복사생성자를 가지고 있는것을 이용해서 </span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; save_values &#123;values&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 시작 반복, 끝 반복의 범위를 지정해서 초기화도 가능</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; samples &#123;++cbegin(values), --cend(values)&#125;;  <span class="comment">// const 반복자</span></span><br><span class="line"><span class="comment">// list이기 때문에, begin과 end가 반환하는 반복자는 양방향이므로 정숫값을 더하거나, 뺄수가 없다.</span></span><br><span class="line"><span class="comment">// 위치를 수정하는 방법은 증가연산(++), 감소연산(--)를 사용하는것.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위는 2번째부터 끝에서 2번째까지 돌면서 초기화한다.</span></span><br></pre></td></tr></table></figure><h2>윈소 추가하기</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push_back, push front 함수가 있긴하지만, 복사한다는 단점이 있다.</span></span><br><span class="line"><span class="comment">// emplace_back, emplace_front 함수가 있는데 RValue 참조 매개변수 버전이다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert 함수 맴버를 이용해 리스트 내부에 원소를 추가할수 있다.</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; data(<span class="number">10</span>, <span class="number">55</span>);</span><br><span class="line">data.insert(++begin(data), <span class="number">66</span>); <span class="comment">// 두번째 원소를 66으로 삽입</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// data </span></span><br><span class="line"><span class="comment">// 55 66 55 55 55 55 55 55 55 55 55</span></span><br><span class="line"><span class="keyword">auto</span> iter = begin(data);</span><br><span class="line"><span class="built_in">std</span>::advance(iter, <span class="number">9</span>); <span class="comment">// iter을 9만큼 루프돌려서 증감.</span></span><br><span class="line">data.insert(iter, <span class="number">3</span>, <span class="number">88</span>); <span class="comment">// 10번째 위치에 88의 복제번을 3개 삽입한다.</span></span><br><span class="line"><span class="comment">// 55 66 55 55 55 55 55 55 55 88 88 88 55 55</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(<span class="number">10</span> ,<span class="number">5</span>);</span><br><span class="line">data.insert(--(--end(data)), cbegin(numbers), cend(numbers));</span><br><span class="line"><span class="comment">// data 리스트의 끝에서 2번 뒤인 위치에서 벡터 numbers 시작부터 벡터 end까지 삽입한다.</span></span><br><span class="line"><span class="comment">// 55 66 55 55 55 55 55 55 55 88 88 88 5 5 5 5 5 5 5 5 5 5 55 55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert -&gt; emplace </span></span><br><span class="line"><span class="comment">// push_back -&gt; emplace_back</span></span><br><span class="line"><span class="comment">// pusk_front -&gt; emplace_front를 사용하자</span></span><br></pre></td></tr></table></figure><p><a href="http://jeremyko.blogspot.kr/2012/08/lvalue-rvalue.html" target="_blank" rel="noopener">RValue and LValue 설명</a></p><h2>원소 제거</h2><blockquote><p><code>list.clear()</code>, <code>list.erase()</code> 함수 맴버는 다른 순차열과 같이 동작한다. 결과도 같다. <code>list.remove()</code> 맴버는 인수와 일치하는 원소들을 제거한다.</p><p><code>remove_if()</code> 함수 맴버는 <strong><em>단항 조건자</em></strong>를 사용한다. 단항 조건자는 원소 타입이나 원소 타입의 const 참조를 인수로 받고 bool 값을 반환.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.remove_if([](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span> == <span class="number">0</span>;&#125;); <span class="comment">//짝수 제거, 함수객체도 사용가능하다.</span></span><br></pre></td></tr></table></figure><h2>원소 정렬</h2><blockquote><p>algorithm 헤더에 있는 sort 함수 템플릿을 쓰려면 랜덤엑세스 반복자가 필요하다. 리스트 컨테이너에는 랜덤 엑세스 반복자가 없고, 양방향 반복자가 있으므로, 리스트에 있는 원소들에게 sort()  알고리즘을 적용할수 없다.</p><p>하지만  list 컨테이너 내부에 함수가 별도로 제공되고 있다. list의 컨테이너의 sort() 함수는 이항 조건을 인수로 받는다.</p><p>예를 들면 <code>names.sort(std::greator&lt;string&gt;())</code>  functional 헤더에 정의된 greator를 사용하였다. 내림차순</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_greater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> <span class="comment">// 이니셜이 같은 문자열을 길이로 정렬</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="number">0</span>] == s2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> s1.length() &gt; s2.length(); <span class="comment">// 이니셜이 같다면 내림차순</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s1 &gt; s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">names.sort(my_greater()); <span class="comment">// 람다 함수도 가능하다.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;벡터 컨테이너&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;타입 T를 원소를 갖는 컨테이너, Array 컨테이너와 같지만, &lt;strong&gt;&lt;em&gt;더 많은 원소를 수용할수 있도록 크기가 자동으로 커진다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>순차 컨테이너, Array Container</title>
    <link href="https://Mutesk.github.io/2018/03/30/STL-Chapter%202-1/"/>
    <id>https://Mutesk.github.io/2018/03/30/STL-Chapter 2-1/</id>
    <published>2018-03-29T22:24:19.910Z</published>
    <updated>2018-03-29T22:43:22.720Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1>순차 컨테이너</h1><blockquote><p>순차 컨테이너는 윈소들을 선형적인 순차열(Linear Sequence)로 저장.<br>원소들을 정렬하지 않고, 저장한 순서대로 배열된다.</p></blockquote><ul><li><p>array&lt;T, N&gt; 컨테이너</p><ul><li>T타입, 고정길이 N으로 된 순차열</li></ul></li><li><p>vector<t></t></p><ul><li>T 타입, 가변길이 순차열을 정의하며. 필요할때 자동으로 크기가 늘어난다.</li></ul></li><li><p>deque<t></t></p><ul><li>T 타입, 자동으로 길이가 늘어나는 가변길이 순차열, 양쪽 끝에서 원소를 추가하거나 삭제할수 있음.</li></ul></li><li><p>list<t></t></p><ul><li>이중 연결 리스트로 된 가변길이 순차열, 모든 위치에서 원소를 추가하거나 삭제할수 있음.<br>만약 특정 원소에 접근한다면 첫번째 원소에서 리스트를 따라 움직여야되기 때문에, array, vector, deque보다 느리다.</li></ul></li><li><p>forward_list<t></t></p><ul><li>단일 연결 리스트로 연결된 T 객체의 가변길이 순차열 정의<br>리스트 컨테이너보다 빠르고 더 적은 메모리르 사요하지만, 항상 첫번재부터 접근을 시작해야됨</li></ul></li></ul><h2>array &lt;T, N&gt; 컨테이너</h2><blockquote><p>표준배열에 해당하는 컨테이너 타입.</p></blockquote><h3>장점</h3><ol><li>at()을 사용해 원소를 접근하면 범위를 벗어난 인덱스에 접근하는지 탐지가가능</li><li>컨테이너에 몇개의 원소가 있는지 알고 있으니, 함수에 원소의 갯수를 별도로 지정하지않아도 인수로 전달하기가 좋다.</li></ol><h3>원소에 접근하기</h3><blockquote><p>일반배열처럼 배열첨자를 사용할수있다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.at(<span class="number">4</span>) = value.at(<span class="number">3</span>) + <span class="number">2.0</span> * value.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>at에 사용한 인수가 범위를 벗어난 인덱스인지 확인하고, 범위를 벗어났다면 out of range 예외가 발생한다.<br>operator<a href=""></a>에 경계 검사를 하지않는 이유는, 성능때문이다. 원소 접근할때마다 인덱스를 검증한다면<br>오버헤드가 발생하기 때문이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원소들의 합계</span></span><br><span class="line"><span class="keyword">double</span> total &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i &#123;&#125;; i &lt; values.size(); ++i)</span><br><span class="line">total += values[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 컨테이너 비어있는지 확인</span></span><br><span class="line">values.empty(); <span class="comment">// -&gt; return bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 범위기반 for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">total += value;</span><br></pre></td></tr></table></figure><h3>Example</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> min_wt&#123; <span class="number">100U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> max_wt&#123; <span class="number">250U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> wt_step&#123; <span class="number">10U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> wt_count&#123; <span class="number">1</span> + (max_wt - min_wt) / wt_step &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> min_ht&#123; <span class="number">48U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> max_ht&#123; <span class="number">84U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ht_step&#123; <span class="number">2U</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ht_count&#123; <span class="number">1</span> + (max_ht - min_ht) / ht_step &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> lbs_per_kg&#123; <span class="number">2.20462</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ins_per_m&#123; <span class="number">39.3701</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, wt_count&gt; weight_lbs;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, wt_count&gt; height_lns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123;&#125;, w&#123; min_wt &#125;; i &lt; wt_count; w += wt_step, ++i)</span><br><span class="line">weight_lbs.at(i) = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> h&#123; min_ht &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; height : height_lns)</span><br><span class="line">&#123;</span><br><span class="line">height = h;</span><br><span class="line">h += ht_step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">7</span>) &lt;&lt; <span class="string">" |"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; w : weight_lbs)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">7</span>) &lt;&lt; w &lt;&lt; <span class="string">" |"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123; <span class="number">1</span> &#125;; i &lt; wt_count; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------------\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> bmi&#123;&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> feet&#123;&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inches&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> inches_per_foot&#123; <span class="number">12U</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; h : height_lns)</span><br><span class="line">&#123;</span><br><span class="line">feet = h / inches_per_foot;</span><br><span class="line">inches = h % inches_per_foot;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">7</span>) &lt;&lt; feet &lt;&lt; <span class="string">"'"</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">2</span>) &lt;&lt; inches &lt;&lt; <span class="string">"\""</span> &lt;&lt; <span class="string">"|"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; w : weight_lbs)</span><br><span class="line">&#123;</span><br><span class="line">bmi = h / ins_per_m;</span><br><span class="line">bmi = (w / lbs_per_kg) / (bmi * bmi);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">2</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; bmi &lt;&lt; <span class="string">" |"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i&#123; <span class="number">1</span> &#125;; i &lt; wt_count; ++i)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------------\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>Array Container Iterator 사용</h3><blockquote><p>array에는 begin(), end()가 정의되어 있음.<br>실제 이터레이터 타입은 <code>std::array&lt;T, N&gt;::iterator</code>가 실제타입<br>std::generate() 함수 템플릿을 이용하면, 함수 객체가 계산한 값으로 범위를 초기활수도 있음.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> height &#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::generate(<span class="built_in">std</span>::begin(height_ins), <span class="built_in">std</span>::end(height_ins), </span><br><span class="line">[height, &amp;min_ht, &amp;ht_step] () <span class="keyword">mutable</span></span><br><span class="line">    &#123;<span class="keyword">return</span> height += height == <span class="number">0</span> ? min_ht : ht_step &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>array 컨테이너를 연속값으로 초기화하고싶을때는 numeric 헤더에 있는 iota</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span> , 10&gt; values;</span><br><span class="line"><span class="built_in">std</span>::iota(<span class="built_in">std</span>::begin(values), <span class="built_in">std</span>::end(values), <span class="number">10.0</span>); <span class="comment">// 원소들의 값을 10.0부터 19.0 까지 설정한다.</span></span><br></pre></td></tr></table></figure><p><em><code>operator++()</code> 을 지원하는 타입이라면 iota 함수를 쓸수있다.</em></p><p><em>위의 generate, iota는 알고리즘인데, 순방향 반복자만 있다면 사용가능하다. 즉 다른 컨테이너에서도 사용가능.</em></p><blockquote><p>const iterator를 반환하는 cbegin, cend가 있다.<br>원소에 접근은 하지만 수정은 하지않을때 const 반복자를 사용한다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 5&gt; these &#123;....&#125;;</span><br><span class="line"><span class="keyword">double</span> sum &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> start = rbegin(these);</span><br><span class="line"><span class="keyword">auto</span> finish = rend(these);</span><br><span class="line"><span class="keyword">while</span>(start != finish)</span><br><span class="line">sum += *(start++);</span><br></pre></td></tr></table></figure><h3>Array Conatiner 비교</h3><blockquote><p>두 Array 컨테이너의 크기가 같고 원소가 같고, 이 타입이 비교연산을 지원한다면 비교연산자를 사용할수 있다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; these &#123; ... &#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; those &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(these == those)</span><br><span class="line"><span class="comment">// 모든 원소가 일치해야된다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(these != those)</span><br><span class="line"><span class="comment">// 대응되지않은 원소가 하나이상 있다면</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(these &lt; those)</span><br><span class="line"><span class="comment">// 같이 순회하면서 만약 these[i] &lt; those[i] 를 만족하는 해가 나온다면 true다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(these &gt; those)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1&gt;순차 컨테이너&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;순차 컨테이너는 윈소들을 선형적인 순차열(Linear Sequence)로 저장.&lt;br&gt;
원소들을 정렬하지 않고, 저장한 순서대로 배열된다.&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>집계함수, 앨리어싱, Order By, Group By, HAVING, JOIN</title>
    <link href="https://Mutesk.github.io/2018/03/27/SQL-2-day/"/>
    <id>https://Mutesk.github.io/2018/03/27/SQL-2-day/</id>
    <published>2018-03-26T22:38:29.669Z</published>
    <updated>2018-03-26T22:48:38.417Z</updated>
    
    <content type="html"><![CDATA[<h1>집계 함수</h1><h2>평균</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(budget)</span><br><span class="line"><span class="keyword">FROM</span> films;</span><br></pre></td></tr></table></figure><h2>최댓값</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(budget)</span><br><span class="line"><span class="keyword">FROM</span> films;</span><br></pre></td></tr></table></figure><h2>합계</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(budget)</span><br><span class="line"><span class="keyword">FROM</span> films;</span><br></pre></td></tr></table></figure><h1>WHERE 절과 집계함수의 조합</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(budget)</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year &gt;= <span class="number">2010</span>;</span><br></pre></td></tr></table></figure><blockquote><p>2010이후에 나온 영화중 (budget)의 합계</p></blockquote><h2>Example</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 2000년과 2012사이에 나온 영화중 gross중 가장 좋은 값</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(gross)</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"># A로 시작하는 영화중, gross가 평균값</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(gross) <span class="keyword">from</span> films <span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'A%'</span></span><br></pre></td></tr></table></figure><h1>Select 산술</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="number">4</span> * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&gt; 12</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="number">4</span> / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&gt; 1 </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">45</span> / <span class="number">10</span> * <span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line">&gt; 400</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">45</span> * <span class="number">100.0</span> / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt; 450.0</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="number">4.0</span> / <span class="number">3.0</span>) <span class="keyword">AS</span> <span class="keyword">result</span>;  </span><br><span class="line"></span><br><span class="line">&gt; result = 1.333333...</span><br><span class="line"># 살수형 계산이기 때문에 소수점으로 나온다.</span><br></pre></td></tr></table></figure><h1>AS 앨리어싱</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(budget), <span class="keyword">MAX</span>(<span class="keyword">duration</span>)</span><br><span class="line"><span class="keyword">FROM</span> films;</span><br><span class="line"></span><br><span class="line"># 이 쿼리를 처리하면, Query Result에는 구분할수가 없다.</span><br><span class="line"># MAX - budget 결과 MAX - duration 결과가 나온다 (칼럼이름이 구분할수가없다.)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(budget) <span class="keyword">AS</span> max_budget,</span><br><span class="line">       <span class="keyword">MAX</span>(<span class="keyword">duration</span>) <span class="keyword">AS</span> max_duration</span><br><span class="line"><span class="keyword">FROM</span> films;</span><br></pre></td></tr></table></figure><h2>Example</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 영화 타이틀과 넷 프로핏(총 제작비 - 예산) 한 모든 필름을 출력.</span><br><span class="line"><span class="keyword">select</span> title, (gross - budget) <span class="keyword">as</span> net_profit <span class="keyword">from</span> films;</span><br><span class="line"></span><br><span class="line"># 영화 타이틀과 재생시간을 가져오되, 재생시간은 시간으로 출력해야만 하고, 재생시간은 duration_hours으로 출력한다.</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(<span class="keyword">duration</span> / <span class="number">60.0</span>) <span class="keyword">as</span> avg_duration_hours <span class="keyword">from</span> films;</span><br><span class="line"></span><br><span class="line"># 모든 필름의 평균 재생시간을 가져오되 시간으로 출력할것.</span><br><span class="line"><span class="keyword">select</span> title, (<span class="keyword">duration</span> / <span class="number">60.0</span> ) <span class="keyword">as</span> duration_hours <span class="keyword">from</span> films</span><br><span class="line"></span><br><span class="line"># 시민의 사망비율을 가져온다. </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(deathdate) * <span class="number">100.0</span> / <span class="keyword">count</span>(*) <span class="keyword">as</span> percentage_dead <span class="keyword">from</span> people</span><br><span class="line"></span><br><span class="line"># 가장오래된 영화년도와 가장 최신영화의 년도의 차이를 구하라</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(release_year) - <span class="keyword">MIN</span>(release_year) <span class="keyword">as</span> <span class="keyword">difference</span> <span class="keyword">from</span> films</span><br></pre></td></tr></table></figure><h1>Order By</h1><blockquote><p>하나이상의 칼럼을 오름차순 또는 내림차순으로 정렬한다.</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> release_year <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"># release_year을 내림차순 정렬하여 title 출력</span><br></pre></td></tr></table></figure><blockquote><p>ORDER BY가 기본값으로 텍스트 칼럼을 정렬한다면 알파벳 정렬</p></blockquote><h2>Example</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 사람들의 이름을 알파벳순으로 정렬해서 출력</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> people <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">2000</span>년 또는 <span class="number">2012</span>년에 나온 영화이름을 오름차순 정렬하여 출력</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> films <span class="keyword">where</span> release_year = <span class="number">2000</span> <span class="keyword">OR</span> release_year = <span class="number">2012</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> release_year <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2015</span>년에 개봉하지 않은 영화들 모든 칼럼을 <span class="keyword">duration</span>에 정렬하여 출력</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> films <span class="keyword">where</span> release_year &lt;&gt; <span class="number">2015</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">duration</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># M자로 시작하는 영화들의 타이틀과 수익을 타이틀을 알파벳 정렬하여 출력</span><br><span class="line"><span class="keyword">select</span> title, gross <span class="keyword">from</span> films <span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'M%'</span> <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> imdb_score, film_id <span class="keyword">from</span> reviews <span class="keyword">order</span> <span class="keyword">by</span> imdb_score <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"># 모든 영화의 이름을 역순으로 출력</span><br><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> films <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> birthdate, <span class="keyword">name</span> <span class="keyword">from</span> people <span class="keyword">order</span> <span class="keyword">by</span> birthdate <span class="keyword">asc</span>, deathdate <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> release_year, <span class="keyword">duration</span>, title <span class="keyword">from</span> films <span class="keyword">order</span> <span class="keyword">by</span> release_year <span class="keyword">asc</span>, <span class="keyword">duration</span> <span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> certification, release_year, title <span class="keyword">from</span> films <span class="keyword">order</span> <span class="keyword">by</span> certification <span class="keyword">asc</span>, release_year <span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, birthdate <span class="keyword">from</span> people <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">asc</span>, birthdate <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><h1>Group By</h1><blockquote><p>결과를 하나 이상의 열로 그룹화.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sex, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><blockquote><p>공통적으로 Group By는 집계 함수와 같이 사용한다.<br>Group By는 항상 after 절 이후에 나온다.<br>그리고 Group By 후엔 항상 Order by가 나온다. 그리고 Order by로 쿼리가 끝을 내야된다.</p></blockquote><h2>Example</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 매년 나오는 영화의 갯수 출력</span><br><span class="line"><span class="keyword">select</span> release_year, <span class="keyword">count</span>(*) <span class="keyword">from</span> films <span class="keyword">group</span> <span class="keyword">by</span> release_year <span class="keyword">order</span> <span class="keyword">by</span> release_year <span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line"># 매년 나오는 영화의 평균 시간</span><br><span class="line"><span class="keyword">select</span> release_year, <span class="keyword">avg</span>(<span class="keyword">duration</span>) <span class="keyword">from</span> films <span class="keyword">group</span> <span class="keyword">by</span> release_year <span class="keyword">order</span> <span class="keyword">by</span> release_year <span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 출시 년도와 매년 낮은 gross</span><br><span class="line"><span class="keyword">select</span> release_year, <span class="keyword">min</span>(gross) <span class="keyword">from</span> films <span class="keyword">group</span> <span class="keyword">by</span> release_year <span class="keyword">order</span> <span class="keyword">by</span> release_year</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> release_year, country, <span class="keyword">max</span>(budget) <span class="keyword">from</span> films</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> release_year, country <span class="keyword">order</span> <span class="keyword">by</span> release_year, country</span><br></pre></td></tr></table></figure><h1>Having</h1><blockquote><p>집계 함수는 WHERE 절에서 사용할수가 없는데, 이를 사용하기 위해서 HAVING 절을 이용한다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> release_year</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> release_year</span><br><span class="line">WHERE COUNT(title) &gt; 10;  # invalid Query</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> release_year</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> release_year</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(title) &gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> release_year, <span class="keyword">AVG</span>(budget) <span class="keyword">AS</span> avg_budget, <span class="keyword">AVG</span>(gross) <span class="keyword">AS</span> avg_gross</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year &gt; <span class="number">1990</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> release_year</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(budget) &gt; <span class="number">60000000</span>;</span><br></pre></td></tr></table></figure><h1>Join</h1><blockquote><p>예를 들어서 설명하자면, films 테이블에서 영화 ID를 가지고 IMDB 정보인 reviews 테이블을 조회하고 싶을때,<br>SQL에서는 Join이라는 개념으로 가져온다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, imdb_score</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">JOIN</span> reviews</span><br><span class="line"><span class="keyword">ON</span> films.id = reviews.film_id</span><br><span class="line"><span class="keyword">WHERE</span> title = <span class="string">'To Kill a Mockingbird'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>'To Kill a Mockingbird’라는 영화의 IMDB 점수를 가져온다.<br>조인에 대해서는 다음에 더 정리, Group By와 섞어쓰는것 대해서 더 공부를 해야겠다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;집계 함수&lt;/h1&gt;
&lt;h2&gt;평균&lt;/h2&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
      <category term="sql" scheme="https://Mutesk.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>반복자, 컨테이너, 알고리즘, 람다함수, 함수객체</title>
    <link href="https://Mutesk.github.io/2018/03/26/STL-Chapter-1/"/>
    <id>https://Mutesk.github.io/2018/03/26/STL-Chapter-1/</id>
    <published>2018-03-26T07:05:29.964Z</published>
    <updated>2018-03-26T07:30:08.097Z</updated>
    
    <content type="html"><![CDATA[<h1>STL</h1><ol><li>컨테이너 라이브러리에는 데이터를 저장하고 관리하는데 쓸수있는 컨테이너가 정의되어 있음.</li><li>반복자 라이브러리에는 반복자가 정의되어 있으며, 반복자는 포인터처럼 동작하는 객체로 컨테이너에 있는 객체의 순차열을 참조할때 사용</li><li>알고리즘 라이브러리에는 컨테이너에 저장된 원소에 적용할수 있는 알고리즘이 폭넓게 정의되어 있다.</li><li>수치 라이브러리에는 숫자와 관련된 기능이 폭넓게 정의되어 있으며, 원소에 수치 처리 기능이 있다.</li></ol><h1>템플릿</h1><blockquote><p>함수나 클래스를 매개변수로 작성한 명세.<br>매개변수화 타입 별칭으로 템플릿을 정의할수도 있다.</p></blockquote><h1>컨테이너</h1><blockquote><p>STL의 기능 대부분은 컨테이너와 관련되어 있다. STL의 근본이라고도 할수 있음.<br>컨테이너는 객체를 일정한 방식으로 저장하고 조직화하는 객체를 말한다.</p></blockquote><ul><li>순차 컨테이너는 객체들을 선형으로 저장하고, 반드시 연속으로 저장하지는 않는다.</li><li>연관 컨테이너는 객체들을 연관된 키와 함께 저장한다.</li><li>컨테이너 어댑터는 순차 컨테이너나 연관 컨테이너에 저장된 데이터에 접근하는 다른방법을 제공하는 어댑터 클래스 템플릿을 말한다.</li><li>기본적으로 T 객체를 컨테이너에 저장하려면 조건이 있는데, 기본생성자, 복사생성자, 소멸자, 할당연산자가 필요하다.</li></ul><blockquote><p>객체들이 RValue가 아니면 모든 STL 컨테이너는 객체를 저장할때 복사본을 저장하고,<br>STL에서 이동 생성자와 이동 할당 연산자가 반드시 noexcept로 지정되어야 된다.<br>컨테이너는 객체들을 힙에 저장하고 객체가 차지하는 공간도 자동으로 관리한다. 할당자 <code>std::allocator&lt;T&gt;</code> 담당한다.</p></blockquote><h1>반복자</h1><blockquote><p>포인터와 비슷하게 동작하는 클래스 템플릿 타입의 객체<br>반복자를 사용하면, 컨테이너에 있는 원소들에 접근하면서 일정한 방식으로 원소들을 처리할수 있다.</p></blockquote><h2>반복자 카테고리</h2><ol><li>읽기 반복자<br><code>*iter</code>을 지원한다.</li><li>출력 반복자<br><code>*iter = new_value</code>을 지원한다.</li><li>순방향 반복자</li><li>양방향 반복자</li><li>랜덤 엑세스 반복자</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> data[]&#123; <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">6.5</span>, <span class="number">5.5</span>, <span class="number">8.5</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"배열 원소들:\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin(data); iter != end(data); ++iter)  <span class="comment">// begin, end가 배열 원소 나열하는 데 쓰일 반복자 반환하는데 쓰이고 있음.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;  <span class="comment">// *iter 반복자를 역참조해서 참조에 의한 값에 접근한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> total = accumulate(begin(data), end(data), <span class="number">0.0</span>);  <span class="comment">// 함수 인수로 begin과 end가 사용됨 &amp; accumulate 함수는 operator+()가 지원되어야 된다.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"배열 원소의 합계 : "</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>스트림 반복자</h2><blockquote><p>스트림과 소스 또는 스트림과 타깃 사이에 데이터를 텍스트 모드로 전송할수 있다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"값은 공백으로 구분해서 입력. 종료하려면 Ctrl + Z"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n입력한 값의 합은 "</span></span><br><span class="line">&lt;&lt; accumulate(istream_iterator&lt;<span class="keyword">double</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cin</span>), istream_iterator&lt;<span class="keyword">double</span>&gt;(), <span class="number">0.0</span>) <span class="comment">// istream_iterator&lt;double&gt;() 끝 스트림 반복자, </span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>알고리즘</h1><blockquote><p>알고리즘은 데이터 원소들을 반복자로 접근하기 때문에 알고리즘은 데이터가 저장되는 위치에 관여하지않는다.</p></blockquote><h2>알고리즘 분류</h2><ol><li>변경불가 순차열 연산, 순차열의 내용을 변경하지 못한다.</li><li>변경가능 순차열 연산, 순차열의 내용을 변경한다.</li><li>정렬, 병합과 관련된 알고리즘은 순차열의 순서를 변경한다.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> data[]&#123; <span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform(시작인자, 끝인자, 결과로 돌려줄 시작위치를 지정하는 반복자, 입력범위에 적용될 함수);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체 전달하기</span></span><br><span class="line"><span class="comment">// functor</span></span><br><span class="line">Root root;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Squre Roots are : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">transform(begin(data), end(data), ostream_iterator&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>), root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다 표현식을 인수로 사용하기</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\nCubes are : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">transform(begin(data), end(data), ostream_iterator&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>),</span><br><span class="line">[](<span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x * x * x; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function&lt;&gt; 타입의 변수를 인수로 사용하기</span></span><br><span class="line">function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>)&gt; op&#123; [](<span class="keyword">double</span> x) &#123;<span class="keyword">return</span> x * x; &#125; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\nSquares are : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">transform(begin(data), end(data), ostream_iterator&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>), op);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다른 람다 표현식을 호출하는 람다 표현식을 인수로 사용하기</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n4th Power are : "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">transform(begin(data), end(data), ostream_iterator&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>),</span><br><span class="line">[&amp;op](<span class="keyword">double</span> x) &#123;<span class="keyword">return</span> op(x) * op(x); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>문제풀이</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> strArr[]&#123;</span><br><span class="line"><span class="string">"Example to Zero"</span>,</span><br><span class="line"><span class="string">"Example to One"</span>,</span><br><span class="line"><span class="string">"Example to Two"</span>,</span><br><span class="line"><span class="string">"Example to Three"</span>,</span><br><span class="line"><span class="string">"Example to Four"</span>,</span><br><span class="line"><span class="string">"Example to Five"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복자를 사용해 배열의 내용을 한줄에 하나씩 출력</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : strArr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// transform을 사용하여 단어의 모든 소문자를 *로 대체하고, 표준 출력 스트림으로 한줄에 하나씩 출력</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span> iter : strArr)</span><br><span class="line">&#123;</span><br><span class="line">transform(begin(iter), end(iter), ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>, <span class="string">""</span>),</span><br><span class="line">[](<span class="keyword">char</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= <span class="number">97</span> &amp;&amp; a &lt;= <span class="number">122</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Test Version \n"</span>;</span><br><span class="line">transform(begin(strArr), end(strArr), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>), </span><br><span class="line">[](<span class="built_in">string</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">97</span> &amp;&amp; i &lt;= <span class="number">122</span>)</span><br><span class="line">i = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform을 사용하여 단어의 모든 문자를 대문자로 바꾸는 프로그램 작성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : strArr)</span><br><span class="line">&#123;</span><br><span class="line">transform(begin(iter), end(iter), ostream_iterator&lt;<span class="keyword">char</span>&gt;(<span class="built_in">cout</span>, <span class="string">""</span>), [](<span class="keyword">char</span> a) &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(::<span class="built_in">toupper</span>(a)); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Test Version \n"</span>;</span><br><span class="line">transform(begin(strArr), end(strArr), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>),</span><br><span class="line">[](<span class="built_in">string</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : b)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(::<span class="built_in">toupper</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;STL&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 라이브러리에는 데이터를 저장하고 관리하는데 쓸수있는 컨테이너가 정의되어 있음.&lt;/li&gt;
&lt;li&gt;반복자 라이브러리에는 반복자가 정의되어 있으며, 반복자는 포인터처럼 동작하는 객체로 컨테이너에 있는 객체의 
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>가상함수</title>
    <link href="https://Mutesk.github.io/2018/03/26/Virtual-Function/"/>
    <id>https://Mutesk.github.io/2018/03/26/Virtual-Function/</id>
    <published>2018-03-25T20:09:43.030Z</published>
    <updated>2018-03-25T20:48:31.107Z</updated>
    
    <content type="html"><![CDATA[<h1>객체 포인터의 참조관계</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Person형 포인터는 Person 객체뿐만이 아니라, Person을 상속하는 유도 클래스의 객체도 가르킬수 있음.<br>즉, C++에선, A형 포인터 변수는 A 객체 또는 A를 직접 혹은 간접적으로 상속하는 모든 객체를 가르킬수 있음.</p></blockquote><p><strong>하지만 이 관계에서, 함수 오버라이딩이 있다면 원래의 형이 아닌, 현재 포인터의 형태의 함수를 호출하게 된다.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseFunc</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base Function"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DerivedFunc</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived Function"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *bptr = <span class="keyword">new</span> Base(); <span class="comment">// 컴파일 OK</span></span><br><span class="line">    bptr-&gt;DerivedFunc(); <span class="comment">// 컴파일 에러</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C++ 컴파일러는, 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하지, 실제 가르키는 객체의 자료형을 기준으로 판단하지 않는다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *bptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    Derived *dptr = bptr; <span class="comment">// 컴파일 에러  -&gt; 다운 캐스팅 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>다운캐스팅에서 에러가 발생하는 원인은, 컴파일러가 bptr이 실제로 가리키는 객체가 Derived 객체라는 사실을 기억하지 않는다.<br>Derived 포인터의 변수에 Base 포인터 변수을 넣을려고 하기 때문에, 불가능.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived * dptr = <span class="keyword">new</span> Dervied();</span><br><span class="line">    Base *bptr = dptr; <span class="comment">// UpCast OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>dptr은 Derived 클래스의 포인터 변수이기 때문에, 이 객체는 Baes 클래스를 직접 혹은 간접적으로 상속하는 객체이다. Base형 포인터 변수로도 참조가 가능하다.</p></blockquote><h1>가상함수의 등장</h1><blockquote><p><strong>포인터 변수 자료형에 따라 호출되는 함수가 달라지는 것은 문제가 있다.</strong><br>가상함수를 통해 상속과 다형성을 이룰수 있는데, 상속을 통해 연관된 클래스에 대해 공통적인 규약을 정의할수 있게 된다.</p></blockquote><h1>가상소멸자의 사용이유</h1><blockquote><p>앞서 말했다시피, 포인터의 원래의 형태 함수를 호출하는데, 가상소멸자를 쓰지않으면, 포인터의 형태의 소멸자가 호출되게 되고,<br>만약 포인터가 가르키는 값이 자식 클래스의 객체라면, 자식 클래스만 사용하는 메모리 만큼 누수가 생긴다.</p></blockquote><h1>가상함수의 원리</h1><blockquote><p>가상함수가 포함된 클래스가 있을때, 컴파일러가 소스코드 파일을 컴파일하면서 알아낸 정보를 바탕으로 PE파일의 섹션에 기록한다.<br>vtable은 instance 별로 생성되는것이 아니라, 클래스 별로 생기게 된다.<br>해당 가상함수 테이블은 객체의 생성과 상관없이 메모리 공간에 할당된다. 이 테이블이 맴버함수 호출에 사용되는 일종의 데이터</p></blockquote><p><strong>PE파일</strong> : <em>우리가 쓰고 있는 윈도우즈 환경의 실행 파일 포맷을 PE라고 하며, &quot;Portable&quot;의 단어 뜻 그대로 의식성이 있으며 플랫폼에 독립적입니다.</em></p><p><img src="https://postfiles.pstatic.net/MjAxODAzMjZfMTk1/MDAxNTIyMDEwNjI3MTU4.sniw80hGQcRtNlbxiQfS85iPdMw6d1M1Wnjcbs0pbLsg.12pfHiSpCDsninixOdKxe52Dv961pPJyp4ienaPiM9sg.PNG.j0803/%EC%BA%A1%EC%B2%98.PNG?type=w773" alt="가상함수테이블"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;객체 포인터의 참조관계&lt;/h1&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ Chapter 1</title>
    <link href="https://Mutesk.github.io/2018/03/25/EffectiveCppDay1/"/>
    <id>https://Mutesk.github.io/2018/03/25/EffectiveCppDay1/</id>
    <published>2018-03-25T13:26:00.763Z</published>
    <updated>2018-03-25T20:11:50.136Z</updated>
    
    <content type="html"><![CDATA[<h1>Item 1</h1><blockquote><p>현재 C++은 다중 패러다임 프로그래밍 언어.</p></blockquote><blockquote><p>절차적 언어를 기본으로 객체 지향, 함수식, 일반화, 그리고 메타프로그래밍 개념까지 지원.<br><em>C, OOP 개념의 C++, 템플릿 C++, STL</em>이 네가지가 C++을 이루고 있음.</p></blockquote><h1>Item 2</h1><blockquote><p><code>#define</code>을 보다 const, enum, inline을 사용하자.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><blockquote><p>ASPECT_RATIO는 컴파일러에게 넘어가기 전에, Preprocessor에서 숫자 상수로 바꾸어버린다.<br>즉 컴파일러를 통해 Symbol Table에 들어가지 않게 된다.<br>숫자 상수로 바꿔지기 때문에, file Error라도 발생하게 되면 찾기가 힘들어진다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>; <span class="comment">// 으로 사용한다.</span></span><br></pre></td></tr></table></figure><blockquote><p>기호 테이블에도 들어가며, 상수타입 AspectRatio은 딱 한개만 생긴다.</p></blockquote><h2>주의사항</h2><ol><li>Constant Pointer를 사용하는 변수 / 값이 변경될수 있음.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"~~"</span>; </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"~~~"</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>클래스 맴버로 상수를 정의하는 경우</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Numturns = <span class="number">5</span>; <span class="comment">// 상수 선언 -&gt; Declartion이다. Define이 아니다.</span></span><br><span class="line"><span class="keyword">int</span> scores[Numturns];<span class="comment">// 상수 사용 -&gt; 정의가 아니기 때문에 허용 X, 포인터로 동적배열</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Numturns는 cpp파일에서 정의를 해줘야 된다.</span></span><br><span class="line"><span class="comment">const int GamePlayer::Numturns;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">또는</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; Numturns = <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> scores[Numturns];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum은 const보다 #define에 더 가까움. 그리고 #define 처럼, 어떤 형태의 쓸데없는 메모리 할당도 절대 저지르지 않음.</span></span><br><span class="line"><span class="comment">// 이게 템플릿 메타프로그래밍의 핵심 기법임.</span></span><br></pre></td></tr></table></figure><h2>매크로함수, 인라인함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 경우</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);   <span class="comment">// a가 두번 증가하게된다.</span></span><br><span class="line">CALL_WITH_MAX(++a, b + <span class="number">10</span>);   <span class="comment">// a가 한번 증가하게된다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f(a &gt; b ? a : b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 함수는 템플릿이기 때문에, Famliy of Functions을 만들어내고, 동일한 타입의 객체 두개를 인자로 받고 둘 중 큰것을 f에 넘겨서 호출한다.</span></span><br></pre></td></tr></table></figure><h1>Item 3. 낌새만 보이면 const를 들이대 보자.</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">클래스 바깥에서는 전역 혹은 네임스페이스 유효범위의 상수 선언에 사용</span><br><span class="line">파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const 가능</span><br><span class="line">클래스 내부에는 정적 맴버 및 비정적 맴버 모두 상수로 선언할수 있음.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;</span><br><span class="line"><span class="keyword">const</span> * <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 키워드가 *표 왼쪽에 있다면 포인터가 가르키는 대상이 상수</span></span><br><span class="line"><span class="comment">// const 키워드가 *표 오른쪽에 있다면 포인터 자체가 상수</span></span><br></pre></td></tr></table></figure><blockquote><p>함수 반환 값을 상수로 정해주면, 안전성이나 효율을 포기하지 않고도 사용자측의 에러 돌발 상황을 줄이는 효과가 있게 된다.</p></blockquote><h2>상수 맴버 함수</h2><blockquote><p>해당 맴버 함수가 상수 객체에 대해 호출될 함수이다.</p></blockquote><h3>장점</h3><ol><li>클래스의 인터페이스를 이해하기 좋게 한다.<blockquote><p>C++의 실행 성능을 높이는 핵심 기법 중 하나가 상수 객체에 대한 참조자로 진행.</p></blockquote></li></ol><ul><li><p>비트수준 상수성</p><ul><li>어떤 맴버 함수가 그 객체의 어떤 데이터의 맴버도 건드리지 않아야 된다. 그 함수가 const임을 인정하는 개념</li></ul></li><li><p>논리적 상수성</p><ul><li>비트수준 상수성에서 통과하는 상황을 보완하는 개념. 상수 맴버 함수라고 해서 객체의 한 비트도 수정할수 없는 것이 아니라, 일부 몇비트는 바꿀수 있고, 사용자 측에서 알아채지 못하면 된다.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textlength;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lengthIsValid)</span><br><span class="line">&#123;</span><br><span class="line">textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);</span><br><span class="line">lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textlength;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">~~~~~</span><br><span class="line">~~~~~</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">~~~~~</span><br><span class="line">~~~~~</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 코드 중복을 막기 위해서 const_cast을 활용한다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">~~~~~</span><br><span class="line">~~~~~</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line"><span class="comment">// static_cast&lt;const TextBlock&amp;&gt;(*this)[position]) const을 붙여서 const char&amp; operator[]함수를 호출한다.</span></span><br><span class="line"><span class="comment">// const_cast&lt;char &amp;&gt; const char&amp;에 const을 제거 시키고 리턴.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>정리</h2><ol><li>const을 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을수 있고, 함수 매개변수 및 반환 타입에도 붙을수 있으며, 맴버 함수에도 붙을수 있음.</li><li>컴파일러 쪽에서 비트수준 상수성을 지켜야되지만, 우리는 논리적인 상수성을 사용해서 프로그래밍한다.</li><li>상수 맴버 및 비상수 맴버함수가 기능적으로 서로 똑같이 구현되어 있을경우, 코드 중복을 피하는데, 비 상수버전이 상수버전을 호출하게 만든다.</li></ol><h1>Item 4. 객체를 사용하기 전에 반드시 그 객체를 초기화한다.</h1><blockquote><p>기본제공 타입의 객체는 직접 손으로 초기화한다. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문</p></blockquote><blockquote><p>생성자에는 데이터맴버에 대한 대입문을 생성자 본문에 넣는 방법으로 맴버를 초기화 하지말고, 맴버초기화 리스트를 즐겨 사용하자.<br>그리고 초기화 리스트에 데이터를 나열할때는 클래스에 각 데이터 맴버가 선언된 순서와 똑같이 나열한다.</p></blockquote><blockquote><p>여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야된다.<br>비지역 정적 객체를 지역 정적 객체로 바꾸면 된다. -&gt; SingleTon Pattern</p></blockquote><p><strong>정적 객체</strong>는 자신이 생성된 시점부터 프로그램이 끝날때 까지 살아 있는 객체를 말한다.</p><ol><li>전역 객체</li><li>네임스페이스 유효범위에서 정의된 개체</li><li>클래스 안에서 static 으로 선언된 객체</li><li>함수 안에서 static으로 선언된 객체</li><li>파일 유효범위에서 static으로 정의된 객체</li></ol><p>이들 중 함수 안에 있는 정적 객체를 지역 정적 객체, 나머지를 비지역 정적 객체라고 한다.</p><p><strong>번역 단위(Transation Unit)</strong> 는 컴파일을 통해 하나의 목적 파일(Object File)을 만드는 바탕 소스코드를 말한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비정적 정적 객체의 사용법</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span>g_Data_Position[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span>g_Data_HP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span>g_Data_HitDamage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Source</span></span><br><span class="line"><span class="keyword">float</span>g_Data_Position[<span class="number">10</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">10</span>, <span class="number">10</span> &#125;,&#123; <span class="number">10</span>, <span class="number">150</span> &#125;,&#123; <span class="number">145</span>, <span class="number">150</span> &#125;,&#123; <span class="number">140</span>, <span class="number">95</span> &#125;,&#123; <span class="number">140</span>, <span class="number">40</span> &#125;,&#123; <span class="number">61</span>, <span class="number">40</span> &#125;,&#123; <span class="number">36</span>, <span class="number">96</span> &#125;,&#123; <span class="number">114</span>, <span class="number">66</span> &#125;,&#123; <span class="number">64</span>, <span class="number">12</span> &#125;,&#123; <span class="number">63</span>, <span class="number">154</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span>g_Data_HP = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>g_Data_HitDamage = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 바로 초기화를 해줘야 된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  비지역 정적 객체를 지역정적 객체로 바꿀려면  SingleTon 사용한다.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Item 1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;현재 C++은 다중 패러다임 프로그래밍 언어.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;절차적 언어를 기본으로 객체 지향, 함수식, 일반화, 그리고 메타프로그래밍 개념까지 지
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SmartPointer</title>
    <link href="https://Mutesk.github.io/2018/03/24/smartpointer/"/>
    <id>https://Mutesk.github.io/2018/03/24/smartpointer/</id>
    <published>2018-03-24T14:18:56.741Z</published>
    <updated>2018-03-25T20:11:57.485Z</updated>
    
    <content type="html"><![CDATA[<h1>Shared Pointer</h1><ul><li>shared pointer는 여러 파티(각 파티가 포인터를 갖고 있음)에서 공통으로 사용하는 메모리를 관리한다.</li><li>shared_ptr가 더이상 데이터를 참조하지 않는 즉시 메모리를 해제한다. ( Reference Count )</li><li>프로그램을 단순하고, 동시접근가능하게 할때 사용한다.</li><li>모든 스레드가 접근이 끝나면 메모리를 자동으로 해제한다.</li><li>shared ptr은 원하는 만큼 복사가 가능하다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; f();</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p = f();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p.use_count() = "</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래의 방식으로 만들게되면, 메모리 관리 및 데이터 저장하며, 매모리 캐싱이 보다 효율적이다.</span></span><br><span class="line"><span class="comment">// make_shared 함수는 shared_ptr을 반환하기 때문에, 단순화된 자동 타입추론을 사용가능 (auto variable)</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p1 = make_shared&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// shared_ptr은 메모리와 실행 시간에 약간의 오버헤드가 있다. 대신 프로그램을 단순화 할수 있다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; f()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p1&#123; <span class="keyword">new</span> <span class="keyword">double</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p2&#123; <span class="keyword">new</span> <span class="keyword">double</span> &#125;, p3 = p2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p3.use count() = "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수를 반환하면 포인터를 파괴하고 p1이 참조하는 메모리를 해제한다. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2가 만들어지고 p3에 할당연산하면서  use count가 2가 된다.</span></span><br><span class="line"><span class="comment">// p3의 값이 리턴하면서 함수 반환되고 use count가 1이 된다.</span></span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Unique Pointer</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; f();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Unique Ownership 을 나타낸다.</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; dp&#123; <span class="keyword">new</span> <span class="keyword">double</span> &#125;;</span><br><span class="line">*dp = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 따라서 동적으로 할당하지 않은 주소를 할당하면 버그가 발생한다.</span></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt;  dd&#123; &amp;d &#125;; <span class="comment">// 동적으로 할당되지 않은 주소를 할당함.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unique Ptr은 다른 포인터 타입에 할당되거나 암시적으로 변환할 수 없다.</span></span><br><span class="line"><span class="comment">// 원시 포인터에서 포인터의 데이터를 얻고 싶다면 get함수를 이용한다.</span></span><br><span class="line"><span class="keyword">double</span> *raw_dp = dp.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다른 unique_ptr에 할당할 수 없다.</span></span><br><span class="line"><span class="comment">// unique_ptr&lt;double&gt; dp2&#123; dp &#125;;</span></span><br><span class="line"><span class="comment">// dp2 = dp; </span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; dp2;</span><br><span class="line">dp2 = f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_ptr에는 배열을 위한 구현이 있음.</span></span><br><span class="line"><span class="comment">// 이 작업은 메모리를 적절히 해제할 때 필요하다. 특수화를 통해 배열처럼 요소에 접근할수 있는 기능을 제공한다.</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>[]&gt; da&#123; <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">da[i] = i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 그 대신에 연산자 *은 사용할수 없다.</span></span><br><span class="line"><span class="comment">// unique_ptr의 중요한 이점은 원시 포인터에 비해 시간과 메모리에 대한 오버헤드가 전혀 없다는 점이다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_ptr의 고급기능중에 사용자 정의 Deleter를 제공하는 기능이 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; f()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 이 경우 함수의 결과는 이동될 임시 값이므로 Move Semanitcs가 필요가 없다.</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt;&#123;<span class="keyword">new</span> <span class="keyword">double</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Shared Pointer&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;shared pointer는 여러 파티(각 파티가 포인터를 갖고 있음)에서 공통으로 사용하는 메모리를 관리한다.&lt;/li&gt;
&lt;li&gt;shared_ptr가 더이상 데이터를 참조하지 않는 즉시 메모리
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SELECT SQL</title>
    <link href="https://Mutesk.github.io/2018/03/24/SQL-1-day/"/>
    <id>https://Mutesk.github.io/2018/03/24/SQL-1-day/</id>
    <published>2018-03-24T14:00:23.000Z</published>
    <updated>2018-03-24T14:01:08.793Z</updated>
    
    <content type="html"><![CDATA[<h1>SELECT DISTINCT</h1><blockquote><p>중복값이 결과에 많아질때, Unqiue 한 값만 Select 하고싶을때 사용한다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">language</span></span><br><span class="line"><span class="keyword">FROM</span> films;</span><br></pre></td></tr></table></figure><h1>SELECT COUNT</h1><blockquote><p>COUNT 문장은 조건에 맞는 칼럼의 수를 리턴함.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> people;</span><br></pre></td></tr></table></figure><blockquote><p>만약 특정한 컬럼의 non-missing 값을 카운팅하고싶다면, COUNT(칼럼이름)을 하면된다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(birthdate)</span><br><span class="line"><span class="keyword">FROM</span> people;</span><br></pre></td></tr></table></figure><blockquote><p>중복되지 않은 값만 카운트하고 싶다면</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> birthdate)</span><br><span class="line"><span class="keyword">FROM</span> people;</span><br></pre></td></tr></table></figure><h1>WHERE 키워드</h1><blockquote><p>테이블 안의 문장 그리고 숫자 값 기반으로 필터링한다.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">= equal</span><br><span class="line">&lt;&gt; not equal</span><br><span class="line">&lt; less then</span><br><span class="line">&gt; greater then</span><br><span class="line">&lt;= less than or equal to</span><br><span class="line">&gt;= greater than or equal to</span><br></pre></td></tr></table></figure><p>예를 들면,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> title = <span class="string">'Metropolis'</span>;</span><br></pre></td></tr></table></figure><h1>숫자 필터링</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> budget &gt; <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h1>텍스트 필터링</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> country = <span class="string">'China'</span>;</span><br></pre></td></tr></table></figure><h1>2개의 WHERE 절</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year &gt; <span class="number">1994</span></span><br><span class="line"><span class="keyword">AND</span> release_year &lt; <span class="number">2000</span>;</span><br></pre></td></tr></table></figure><ul><li>1994년과 2000년 사이에 나온 영화의 타이틀 리턴</li></ul><h1>WHERE AND절과 OR절</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year = <span class="number">1994</span></span><br><span class="line"><span class="keyword">OR</span> release_year = <span class="number">2000</span>;</span><br></pre></td></tr></table></figure><ul><li>1994년작 또는 2000년작의 영화 리턴</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> (release_year = <span class="number">1994</span> <span class="keyword">OR</span> release_year = <span class="number">1995</span>)</span><br><span class="line"><span class="keyword">AND</span> (certification = <span class="string">'PG'</span> <span class="keyword">OR</span> certification = <span class="string">'R'</span>);</span><br></pre></td></tr></table></figure><ul><li>1994년작 또는 1995년작 이고, 인증이 PG이거나 R인 영화의 이름.</li></ul><h1>BETWEEN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year &gt;= <span class="number">1994</span></span><br><span class="line"><span class="keyword">AND</span> release_year &lt;= <span class="number">2000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> films</span><br><span class="line"><span class="keyword">WHERE</span> release_year</span><br></pre></td></tr></table></figure><ul><li>위의 SQL문을 BETWEEN 1994 AND 2000; 로 표현가능</li></ul><h1>WHERE IN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> kids</span><br><span class="line"><span class="keyword">WHERE</span> age = <span class="number">2</span></span><br><span class="line"><span class="keyword">OR</span> age = <span class="number">4</span></span><br><span class="line"><span class="keyword">OR</span> age = <span class="number">6</span></span><br><span class="line"><span class="keyword">OR</span> age = <span class="number">8</span></span><br><span class="line"><span class="keyword">OR</span> age = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> kids</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>위의 SQL문을 아래의 SQL문으로 사용가능함. 단, OR 연산만 가능함.</li></ul><h1>NULL, is NULL</h1><blockquote><p>NULL = 없거나, 알수없는 값. NULL은 IS NULL로 체크가 가능하다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> people</span><br><span class="line"><span class="keyword">WHERE</span> birthdate <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>만약 NULL이 아닌 값만 출력하고 싶다면, IS NOT NULL을 사용한다.</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> people</span><br><span class="line"><span class="keyword">WHERE</span> birthdate <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h1>LIKE, NOT LIKE</h1><p>와일드카드 %d을 사용하여, 조건절에서 문자열을 검사함.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> companies</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'Data%'</span>;</span><br></pre></td></tr></table></figure><ul><li>이름이 Data로 시작하면 출력</li></ul><blockquote><p>NOT LIKE을 쓰면 해당 조건이 아닌것이 출력<br>’_r%’ 언더라인은 무시하는 값, 즉 이건 두번째가 r로 시작하는 문자열</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;SELECT DISTINCT&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;중복값이 결과에 많아질때, Unqiue 한 값만 Select 하고싶을때 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="sql" scheme="https://Mutesk.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Upcast and Downcast</title>
    <link href="https://Mutesk.github.io/2018/03/23/Upcast-and-Downcast/"/>
    <id>https://Mutesk.github.io/2018/03/23/Upcast-and-Downcast/</id>
    <published>2018-03-23T01:48:23.000Z</published>
    <updated>2018-03-23T02:15:28.261Z</updated>
    
    <content type="html"><![CDATA[<h1>Upcasting</h1><blockquote><p>클래스 객체를 기반 클래스로 변환</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *b = <span class="keyword">new</span> Derived(); <span class="comment">// Type Slice와 달리 포인터이므로, 원래의 형만 바꿔준다면 자식의 값과 함수를 사용할수 있음.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">    Derived *d = <span class="keyword">new</span> Derived();</span><br><span class="line">    Base *b  = dynamic_case&lt;Base *&gt;(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">포트폴리오의 TCP Fighter의 클라이언트에서, CBaseObject가 CEffect, CPlayer의 부모인데, </span><br><span class="line">가상함수를 통해서 게임 로직처리부는 CBaseObject의 형태의 포인터만 가지고, </span><br><span class="line">Action함수를 통해서 액션처리를 그리고 Draw을 통해서 그리고 있다.</span><br><span class="line"></span><br><span class="line">TCP Fighter의 CBaseObject, CPlayer, CEffect와, GameProc.cpp, PacketRecv.cpp파일 참조</span><br></pre></td></tr></table></figure><p><a href="https://github.com/MutesK/TCPFighter/tree/master/TCPFighterClient/TCPFighter" target="_blank" rel="noopener">깃허브 링크</a></p><ol><li>형만 정확하다면 묵시적으로 캐스팅된다.</li><li>캐스팅 후 자식 클래스에만 정의되어 있는 메소드에는 접근할수 없다.</li></ol><blockquote><p>객체들을 공통 특성으로 처리할때 사용.</p></blockquote><h1>Downcasting</h1><blockquote><p>클래스 객체를 파생 클래스형으로 변환하는 것을 다운 캐스팅</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> Base();</span><br><span class="line">Derived* d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(b);   <span class="comment">// 자식의 인스턴스 포인터에 부모의 포인터를 넘긴다.</span></span><br></pre></td></tr></table></figure><blockquote><p>당연스럽게도 Derived만 가지고 있는 속성들은 사용하면 문제가 발생한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Upcasting&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;클래스 객체를 기반 클래스로 변환&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>전방선언과 타입슬라이스</title>
    <link href="https://Mutesk.github.io/2018/03/22/fordeclarationandtypeslice/"/>
    <id>https://Mutesk.github.io/2018/03/22/fordeclarationandtypeslice/</id>
    <published>2018-03-22T11:19:59.736Z</published>
    <updated>2018-03-22T11:39:41.798Z</updated>
    
    <content type="html"><![CDATA[<h1>전방선언 (forward Declartion)</h1><blockquote><p>프로그램 규모가 커지다보면 파일간의 의존도가 높아져서 컴파일시간이 늘어난다.</p></blockquote><ol><li>‘#include’ 의존성을 최소화에 목적</li></ol><h2>조건</h2><ul><li>포인터 및 참조 형태로 이름만 참조가 가능하다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>  <span class="comment">// 전방선언</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 포인터 형태 이름 참조</span></span><br><span class="line">    B(<span class="keyword">const</span> A* AInstance);</span><br><span class="line">    <span class="comment">// 참조 형태 이름 참조</span></span><br><span class="line">    B(<span class="keyword">const</span> A&amp; AInstance);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>매개변수, 리턴타입을 위한 이름만 참조한다.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetA</span><span class="params">(A a)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">GetA</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>전방선언을 할경우, 컴파일러에게 심볼 테이블에 추가하고, 그 클래스의 정의를 제공해주겠다고 약속한다.</p></blockquote><blockquote><p>cpp 파일에는 헤더 include가 들어간다. (클래스 정의)</p></blockquote><h1>Type Slice</h1><blockquote><p>부모, 자식 클래스의 오브젝트를 대입시킬때, 자식클래스의 객체를 부모의 객체로 대입시킬때  일부 정보가 사라지는 문제. (Upcast)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> stNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Human <span class="title">H</span><span class="params">(<span class="string">"A"</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">S</span><span class="params">(<span class="string">"B"</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">H = S;      <span class="comment">// 가능</span></span><br><span class="line">S = H;      <span class="comment">// 에러</span></span><br></pre></td></tr></table></figure><p><img src="http://soen.kr/lecture/ccpp/cpp3/30-1-1.files/image002.gif" alt="seon님의 슬라이스 문제"></p><blockquote><p>H 객체에는 stNum에 대응되는 값이 없기 때문에, 날라가게된다.</p></blockquote><h2>반대로 한다면?</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pS = (Student *)&amp;H;</span><br></pre></td></tr></table></figure><p><img src="http://soen.kr/lecture/ccpp/cpp3/30-1-1.files/image004.gif" alt="seon님의 슬라이스 문제"></p><p><em>참고한 곳의 저자가 부모의 포인터는 자식을 가르킬수 있다는 점을 기억해야된다고 함.</em></p><h1>참고 사이트</h1><p><a href="http://soen.kr/lecture/ccpp/cpp3/30-1-1.htm" target="_blank" rel="noopener">타입슬라이스 : Soen.kr 혼자 연구하는 C/C++</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;전방선언 (forward Declartion)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;프로그램 규모가 커지다보면 파일간의 의존도가 높아져서 컴파일시간이 늘어난다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;‘#include’ 의존성을 최소화
      
    
    </summary>
    
    
      <category term="C++" scheme="https://Mutesk.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>A*, JPS</title>
    <link href="https://Mutesk.github.io/2018/03/22/AStarandJPS/"/>
    <id>https://Mutesk.github.io/2018/03/22/AStarandJPS/</id>
    <published>2018-03-22T03:57:58.618Z</published>
    <updated>2018-03-22T09:54:40.819Z</updated>
    
    <content type="html"><![CDATA[<h1>A* 알고리즘</h1><blockquote><p>길 찾기 알고리즘</p></blockquote><ol><li>하나의 노드는 G, H, F값을 가지고 있다.</li></ol><blockquote><p>F = G + H이며, 비용 = 시작점 A부터 이동거리 + 목적지 까지의 휴리스틱 거리</p></blockquote><h2>알고리즘 흐름</h2><ol><li>첫 시작노드를 OpenList에 삽입</li><li>OpenList가 0이 될때까지 반복한다.<ol><li>OpenList에서 가장 작은 노드를 뽑는다.</li><li>CloseList에 넣는다. (방문했다는 표시용)</li><li>만약 이 노드가 목적지라면 리턴</li><li>8방향으로 뻗어서 체크한다.<ol><li>각각 방향이 맵 범위안인지 체크</li><li>장애물이 있는지 체크한다.</li><li>없다면, 노드를 생성한다.<ol><li>방향에 맞게 G 비용을 계산</li><li>해당 좌표가 오픈리스트에 있는지 확인한다.<ol><li>있다면 해당 G비용롸 F비용그리고 부모노드를 바꿔준다.</li></ol></li><li>클로즈리스트에 좌표가 있는지 확인한다.<ol><li>동일 작업한다.</li></ol></li><li>좌표가 어디에도 등록되지 않았다면, 노드생성한다. 그후 오픈리스트에 넣어준다.</li></ol></li></ol></li></ol></li></ol><p><img src="https://github.com/MutesK/AStar/blob/master/AStarAlgorithm/AStar.PNG?raw=true" alt="구동화면"></p><p><a href="https://github.com/MutesK/AStar" target="_blank" rel="noopener">소스코드</a></p><blockquote><p>노랑색이 CloseList이고 에메랄드 색이 OpenList이다. 초록색은 시작점 빨간색이 원하는 도작지점.</p></blockquote><blockquote><p>보면 너무 많은 맵을 탐색했었다.</p></blockquote><h2>Jump Point Search</h2><blockquote><p>무조건 최단 경로가 리턴되지는 않지만, A*에 비해서 매우 빠르다.</p></blockquote><blockquote><p>기본적으로 A*와 비슷하게 동작하지만 Jump하는 조건이 있다.</p></blockquote><ol><li>현재 위치에 대해 속성을 체크하고, Jump함수를 통해 결과가 True라면 노드 생성한다.</li><li>노드 생성할때 A*처럼 OpenList와 CloseList을 검사해서 없다면 생성</li></ol><p><img src="https://github.com/MutesK/AStar/blob/master/AStarAlgorithm/JPS.PNG?raw=true" alt="구동화면"><br><a href="https://github.com/MutesK/JumpPointSearch" target="_blank" rel="noopener">소스코드</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> iX, <span class="keyword">int</span> iY, <span class="keyword">int</span> iDir, <span class="keyword">int</span> *pJumpX, <span class="keyword">int</span> *pJumpY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JumpStack.empty();</span><br><span class="line">st_Jump JumpNode = &#123; iX, iY, iDir, iX, iY &#125;;</span><br><span class="line"><span class="keyword">int</span> X, Y, Dir, JumpX, JumpY;</span><br><span class="line"><span class="keyword">int</span> Xpos;</span><br><span class="line"><span class="keyword">int</span> Ypos;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">JumpNode = JumpStack.top();</span><br><span class="line">JumpStack.pop();</span><br><span class="line"></span><br><span class="line">X = JumpNode.iX;</span><br><span class="line">Y = JumpNode.iY;</span><br><span class="line">Dir = JumpNode.iDir;</span><br><span class="line">JumpX = JumpNode.JumpX;</span><br><span class="line">JumpY = JumpNode.JumpY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 못걷는 상태인데 모르겟다</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 목적지 확인 후 좌표 아웃</span></span><br><span class="line"><span class="keyword">if</span> (X == endPoint-&gt;m_iXpos &amp;&amp; Y == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (iDir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> dfDIR_DD:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X - <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y + <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X + <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return Jump(X, Y + 1, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X, Y + <span class="number">1</span>, iDir, X, Y + <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_RR:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y - <span class="number">1</span>) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X, Y + <span class="number">1</span>) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return Jump(X + 1, Y, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X + <span class="number">1</span>, Y, iDir, X + <span class="number">1</span>, Y &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_UU:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X - <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X + <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y - <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return Jump(X, Y - 1, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X, Y - <span class="number">1</span>, iDir, X, Y - <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_LL:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y - <span class="number">1</span>) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X, Y + <span class="number">1</span>) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return Jump(X - 1, Y, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X - <span class="number">1</span>, Y, iDir, X - <span class="number">1</span>, Y &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> dfDIR_LU:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y + <span class="number">1</span>) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y + <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X + <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y - <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 수직/수평 Jump 재귀 호출</span></span><br><span class="line"><span class="comment">//Jump 후 코너 발견시 현좌표 아웃 return;</span></span><br><span class="line"><span class="comment">// dfDIR_LL 방향 탐색</span></span><br><span class="line"> Xpos = X - <span class="number">1</span>;</span><br><span class="line"> Ypos = Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(Xpos, Ypos - <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos, Ypos + <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos + <span class="number">1</span>) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Xpos--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfDIR_UU 방향 탐색</span></span><br><span class="line">Xpos = X;</span><br><span class="line">Ypos = Y - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos - <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos + <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos - <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ypos--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 방향으로 재귀 Jump</span></span><br><span class="line"><span class="comment">//return Jump(X - 1, Y - 1, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X - <span class="number">1</span>, Y - <span class="number">1</span>, iDir, X - <span class="number">1</span>, Y - <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_RU:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y + <span class="number">1</span>) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y + <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X - <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y - <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dfDIR_RR 방향</span></span><br><span class="line">Xpos = X + <span class="number">1</span>;</span><br><span class="line">Ypos = Y;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos, Ypos - <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos, Ypos + <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos + <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Xpos++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfDIR_UU 방향</span></span><br><span class="line">Xpos = X;</span><br><span class="line">Ypos = Y - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos - <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos + <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos - <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ypos--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 방향으로 재귀 Jump</span></span><br><span class="line">JumpNode = &#123; X + <span class="number">1</span>, Y - <span class="number">1</span>, iDir, X + <span class="number">1</span>, Y - <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_RD:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y - <span class="number">1</span>) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X - <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 수직/수평 Jump 재귀 호출</span></span><br><span class="line"><span class="comment">//Jump 후 코너 발견시 현좌표 아웃 return;</span></span><br><span class="line"><span class="comment">// RR</span></span><br><span class="line">Xpos = X + <span class="number">1</span>;</span><br><span class="line">Ypos = Y;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos, Ypos - <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos, Ypos + <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos + <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Xpos++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DD</span></span><br><span class="line">Xpos = X ;</span><br><span class="line">Ypos = Y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos - <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos + <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos + <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos + <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ypos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// - 방향으로 재귀 Jump</span></span><br><span class="line"><span class="comment">//return Jump(X + 1, Y + 1, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X + <span class="number">1</span>, Y + <span class="number">1</span>, iDir, X + <span class="number">1</span>, Y + <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> dfDIR_LD:</span><br><span class="line"><span class="keyword">if</span> (!CheckWalkable(X, Y - <span class="number">1</span>) &amp;&amp; CheckWalkable(X - <span class="number">1</span>, Y - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(X + <span class="number">1</span>, Y) &amp;&amp; CheckWalkable(X + <span class="number">1</span>, Y + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 수직/수평 Jump 재귀 호출</span></span><br><span class="line"><span class="comment">//Jump 후 코너 발견시 현좌표 아웃 return;</span></span><br><span class="line"><span class="comment">// LL</span></span><br><span class="line">Xpos = X - <span class="number">1</span>;</span><br><span class="line">Ypos = Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos, Ypos - <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos - <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos, Ypos + <span class="number">1</span>) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos + <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Xpos--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DD</span></span><br><span class="line">Xpos = X;</span><br><span class="line">Ypos = Y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (CheckWalkable(Xpos, Ypos))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!CheckWalkable(Xpos - <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos - <span class="number">1</span>, Ypos + <span class="number">1</span>) ||</span><br><span class="line">!CheckWalkable(Xpos + <span class="number">1</span>, Ypos) &amp;&amp; CheckWalkable(Xpos + <span class="number">1</span>, Ypos + <span class="number">1</span>)) ||</span><br><span class="line">Xpos == endPoint-&gt;m_iXpos &amp;&amp; Ypos == endPoint-&gt;m_iYpos)</span><br><span class="line">&#123;</span><br><span class="line">*pJumpX = JumpX;</span><br><span class="line">*pJumpY = JumpY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ypos++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 방향으로 재귀 Jump</span></span><br><span class="line"><span class="comment">//return Jump(X - 1, Y + 1, iDir, pJumpX, pJumpY);</span></span><br><span class="line">JumpNode = &#123; X - <span class="number">1</span>, Y + <span class="number">1</span>, iDir, X - <span class="number">1</span>, Y + <span class="number">1</span> &#125;;</span><br><span class="line">JumpStack.push(JumpNode);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span> (JumpStack.size() &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;A* 알고리즘&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;길 찾기 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;하나의 노드는 G, H, F값을 가지고 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;F = G + H이며, 비용 =
      
    
    </summary>
    
    
      <category term="algorithmn" scheme="https://Mutesk.github.io/tags/algorithmn/"/>
    
  </entry>
  
  <entry>
    <title>백준저지 1193번</title>
    <link href="https://Mutesk.github.io/2018/03/22/BOJ1193/"/>
    <id>https://Mutesk.github.io/2018/03/22/BOJ1193/</id>
    <published>2018-03-22T01:33:05.076Z</published>
    <updated>2018-03-22T06:22:20.132Z</updated>
    
    <content type="html"><![CDATA[<span>$$if \qquad \sum_{n=1}^i A_n \ge \ X일때,  \qquad단 \  A_n = n\\index = \sum_{n=1}^i A_n \ 이고, line = i가\ 된다.$$</span><!-- Has MathJax --><blockquote><p>이때 라인이 홀수인지 짝수인지 판단하고, 그에 맞게 분모와 분자를 조절해주면 된다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> up, down;</span><br><span class="line"><span class="keyword">if</span>(line이 홀수)</span><br><span class="line">&#123;</span><br><span class="line">   up = <span class="number">1</span>;</span><br><span class="line">    down = line;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    up = line;</span><br><span class="line">    down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (line % <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index == X)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; up &lt;&lt; <span class="string">'/'</span> &lt;&lt; down &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            index--;</span><br><span class="line">up++;</span><br><span class="line">down--;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (index == X)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; up &lt;&lt; <span class="string">'/'</span> &lt;&lt; down &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">index--;</span><br><span class="line">up--;</span><br><span class="line">down++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span&gt;$$if \qquad \sum_{n=1}^i A_n \ge \ X일때,  \qquad단 \  A_n = n
\\
index = \sum_{n=1}^i A_n \ 이고, line = i가\ 된다.$$&lt;/span&gt;&lt;!-- Has MathJax 
      
    
    </summary>
    
    
      <category term="algorithmn" scheme="https://Mutesk.github.io/tags/algorithmn/"/>
    
  </entry>
  
  <entry>
    <title>IOCP에 대해</title>
    <link href="https://Mutesk.github.io/2018/03/21/IOCP/"/>
    <id>https://Mutesk.github.io/2018/03/21/IOCP/</id>
    <published>2018-03-21T10:10:45.284Z</published>
    <updated>2018-03-21T11:46:31.264Z</updated>
    
    <content type="html"><![CDATA[<h1>입출력 완료 포트(IOCP)</h1><p><em>비동기 입출력과 완료 포트를 이용하고, 스레드를 효율적으로 관리하며, GQCS에 의해 필요한 스레드만이 깨어난다.</em></p><blockquote><p>APC 큐는 스레드 별로 확인할수 있지만, IOCP는 제약이 없다.</p></blockquote><ol><li>입출력 완료 포트는 CreateIoCompletionPort()을 통해 생성하고, CloseHandle로 파괴한다.</li><li>입출력 완료 포트에 접근하는 스레드를 별로도 두는데, 이를 작업자 스레드라고 부르며, 이를 관리해준다.</li><li>입출력 완료 포트에 저장된 결과를 처리하려면 GetQueuedCompletionStatus() 함수를 통해 처리한다.</li></ol><h2>동작원리</h2><ol><li>응용 프로그램을 구성하는 임의의 스레드에서 비동기 입출력 함수를 호출함으로써 OS 입출력 작업을 요청한다.</li><li>모든 작업자 스레드는 GQCS 함수를 호출하여 입출력 완료 포트를 감시한다. 완료된 비동기 입출력 작업이 아직 없다면, 모든 작업자 스레드는 대기 상태가 된다. 이때 대기 중인 작업자 스레드 목록은 입출력 완료 포트 내부에 저장된다.</li><li>비동기 입출력 작업이 완료되면, 운영체제는 입출력 완료 포트에 결과를 저정한다. 이때 저장되는 정보를 입출력 완료 패킷이라고 부른다.</li><li>운영체제는 입출력 완료 포트에 저장된 작업자 스레드 목록에서 하나를 선택하여 깨운다. 깨어난 작업자 스레드는 비동기 입출력 결과를 처리한다. 이후 작업자 스레드는 필요에 따라, 다시 비동기 입출력 함수를 호출할수 있다.</li></ol><blockquote><p>IOCP에 등록된 핸들(소켓)이 CloseSocket을 한경우, GQCS로 해당 소켓이 오류형식으로 워커스레드가 깨어나고 IOCount를 차감시키는데 소켓은 재활용되므로, 새로 들어온 클라가 끊길수있다.</p></blockquote><h2>Example Note</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">&lt;포함&gt;</span><br><span class="line">클라이언트</span><br><span class="line">&#123;</span><br><span class="line">    SOCKET socket;</span><br><span class="line">    OVERLAPPED Recv;</span><br><span class="line">    OVERLAPPED Send;</span><br><span class="line">    SendQ</span><br><span class="line">    RecvQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">&lt;확장&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOverlapped</span> :</span> <span class="keyword">public</span> OVERLAPPED</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> Mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ConnectedFail =&gt; Connect Queue가 넘쳣을때 - Accept에서 제대로 못빼고있다. =&gt; Accept Thread는 Accept만 처리하게 만들거다.</span><br><span class="line"><span class="comment">// IOCP 핸들</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 워커스레드</span></span><br><span class="line">IOCP 모델에서 PostQueuedCompletionStatus(IOCP, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); 을 넣어서 종료시킨다.</span><br><span class="line">종료 시점</span><br><span class="line">    모든 클라이언트가 정상 종료가 되었다는것을 확인뒤에 종료시킨다.</span><br><span class="line"></span><br><span class="line">-&gt; LPOVERLAPPED, Key, Transfered 변수가 전부 <span class="number">0</span>이라면 정상적으로 워커스레드를 종료시키면된다. </span><br><span class="line"></span><br><span class="line">GetQueuedCompletionStatus에서 LPOVERLAPPED 가 Nullptr || Transfer = <span class="number">0</span>로 나왓다면 에러 상황이다. -&gt; 종료시키자. (물론 로그는 남겨야.. )</span><br><span class="line"></span><br><span class="line">ERROR_NETNAME_DELETE -&gt; 이런 예외처리도 존재한다(해당 소켓이 갑자기 <span class="number">4</span> Way HandShake 없이 끊어진상태 그냥 closesocket만 해주자. 실제로는 이렇게 처리안해줘도 된다.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO Reference Count 방식을 통해 </span><br><span class="line"></span><br><span class="line">Session </span><br><span class="line">&#123;</span><br><span class="line">    Client;</span><br><span class="line">    IOCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IOCount의 증감, 감소를 위해 Interlocked함수 계열을 써야된다.</span></span><br><span class="line"><span class="comment">// 이 세션을 종료시킬 조건은 IOCount = 0일때</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IOCount는 처리하기전에 먼저 올려야된다. -&gt; 큐에 올라가버린다.</span><br><span class="line">에러가 떳는데 IO_PENDING 아니라면 완료 통지가 안오니까 IO--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO 완료되었을때 <span class="number">1</span> 감소시키는데 감소시키는 시점은 </span><br><span class="line">Recv 완료, Send 완료시에 IO차감 시킨다.</span><br><span class="line">IOCount는 초기화는 맨처음에만 한다.</span><br><span class="line"></span><br><span class="line">WorkerThread()</span><br><span class="line">&#123;</span><br><span class="line">    GQCS()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Recv 종료라면)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IO차감</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recv 재등록</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Send 종료라면)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IO차감</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send 재등록</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 차감하는 곳에는 모두 이렇게 들어간다.</span></span><br><span class="line">IO--;</span><br><span class="line"><span class="keyword">if</span>(IO &lt;= <span class="number">0</span>)</span><br><span class="line">    Release();  <span class="comment">// -&gt; 이러면 릴리즈가 2번 걸릴수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 차감을 </span></span><br><span class="line"><span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Release();   <span class="comment">// 외부스레드에서  따로 막아야된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread1(-)</span><br><span class="line">&#123;</span><br><span class="line">    IO++;</span><br><span class="line">    WSARecv();</span><br><span class="line">    <span class="keyword">if</span>(에러)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Release();   <span class="comment">// 외부스레드에서  따로 막아야된다.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerThread(-)</span><br><span class="line">&#123;</span><br><span class="line">    GQCS(-)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">           Release();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이렇게 모든 IO 참조카운트방식의 감소할때는 릴리즈도할수있게 만들어줘야된다.</span></span><br><span class="line"></span><br><span class="line">closesocket </span><br><span class="line">    윈도우 객체 핸들이니깐, 리소스핸들 반환도 한다. GQCS에서 등록된 소켓을 closesocket을 했다면 GQCS 오류로 처리된다.</span><br><span class="line">    -&gt; 소켓 번호는 재사용된다. (그 순간 Accept 된다면 같은 소켓번호를 등록해버린다. <span class="comment">///) -&gt; 예전 꺼의 작업완료통지가 안와버린다.</span></span><br><span class="line">    -&gt; 끊고싶다면 Release()로 하는게 안전함.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIME_WAIT이 왜뜨고 어디에 남는가?</span><br><span class="line"> TCP 상태의 가장 마지막 단계.</span><br><span class="line"></span><br><span class="line">        A                                       B</span><br><span class="line">(FIN_WAIT1)    -&gt;       FIN 보낸다.    -&gt;              (LAST_ACK)</span><br><span class="line"></span><br><span class="line">(TIME_WAIT)    &lt;-     FIN,ACK를 보낸다.  &lt;-            (LAST_ACK)</span><br><span class="line">                (이쪽에서 TIME_WAIT 상태가 된다.)</span><br><span class="line">             -&gt;         ACK를 보낸다.    -&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             &lt;!!!!!!!!!!!! 접속 종료 !!!!!!!!!!!!&gt;</span><br><span class="line"></span><br><span class="line">TIME_WAIT을 안걸리기 위해서</span><br><span class="line">SO_LINGER 옵션을 주고 끊어야 된다.</span><br><span class="line"></span><br><span class="line">-&gt; TIME_WAIT의 문제 : 리소스 문제(포트, 커널)</span><br><span class="line"></span><br><span class="line">Shutdown -&gt; FIN을 넘긴다. -&gt; 우리는 TIME_WAIT을 포기한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">======================================================================================================================================================</span><br><span class="line"></span><br><span class="line">Client</span><br><span class="line">&#123;</span><br><span class="line">    OVERLAPPED      Recv;</span><br><span class="line">    OVERLAPPED      Send;</span><br><span class="line"></span><br><span class="line">    CStreamQ        SendQ;</span><br><span class="line">    CStreamQ        RecvQ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>            SendFlag;       <span class="comment">// 지금 Send를 보내고 있는지 확인 (Interlocked함수 써야된다.)</span></span><br><span class="line">    DWORD           IOCount;        <span class="comment">// 여기도 Interlocked함수 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;  완료 통지에 대해선 순서가 없다. </span><br><span class="line">==&gt;  Transfered 변수가 있다라는건 Send 후에 완료 통지를 보고 버퍼 위치를 옮기면 된다. =&gt; 완전히 보낼때까지 완료 통지가 안온다.</span><br><span class="line">==&gt;  링버퍼 존재가 달라졌다.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;입출력 완료 포트(IOCP)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;비동기 입출력과 완료 포트를 이용하고, 스레드를 효율적으로 관리하며, GQCS에 의해 필요한 스레드만이 깨어난다.&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;APC 큐는 스레드 별로 확인할수 
      
    
    </summary>
    
    
      <category term="Winsock" scheme="https://Mutesk.github.io/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>Overlapped I/O</title>
    <link href="https://Mutesk.github.io/2018/03/21/OverlappedIO/"/>
    <id>https://Mutesk.github.io/2018/03/21/OverlappedIO/</id>
    <published>2018-03-21T09:39:35.660Z</published>
    <updated>2018-03-21T10:10:15.991Z</updated>
    
    <content type="html"><![CDATA[<h1>Event 통지 패턴</h1><blockquote><p>Select 모델은 Reactor 패턴이라고 볼수있다. 그에 반해, Overlapped IO, IOCP는 Proactor 패턴이다.</p></blockquote><h2>Reactor 패턴</h2><p><img src="https://docs.google.com/drawings/d/1w6tNV2wHin9QyotGMF7vOiPXXl6-0aJe6bzOOOcJiTE/pub?w=644&amp;h=417" alt="Reactor Pattern"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reactor 객체를 만들고, 사건 발생시 React가 반응하여, Event Handler에게 이벤트를 발생한다.</span><br><span class="line"></span><br><span class="line">이벤트를 발생하면 역 다중화기를 이용하여, Event Handler 단위로 분할한다.</span><br><span class="line">분할된 이벤트는 해당 Event Handler에게 발송되고(Dispatch)</span><br><span class="line">Event Handler는 알맞은 Method을 통해 이벤트를 처리한다.</span><br><span class="line"></span><br><span class="line">Reactor 패턴에는 리엑터가 등록된 이벤트핸들러들을 들고 관리해야된다.</span><br><span class="line">동시에 수많은 IO 요청이 오면, 이벤트 핸들러가 너무 많아져서, 성능에 좋지 않음.</span><br><span class="line">멀티스레드 활용도가 낮아진다.</span><br></pre></td></tr></table></figure><blockquote><p>Select, Epoll, WSAAEventSelect 등이 이에 해당된다.</p></blockquote><h2>Proactor</h2><img src="http://cfile29.uf.tistory.com/image/21379E4E552AA9E2247E52" style="cursor: pointer;max-width:100%;height:auto" width="700" height="321" filename="proactor_uml.png" filemime="image/jpeg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proactor는 비동기 작업을 지시하고 완료 이벤트 받을 Completion Handler 등록한다.</span><br><span class="line"></span><br><span class="line">비동기 프로세스가 가능한 작업을 대기한다. 혹은 작업이 발생하면 깨어나 처리한다.</span><br><span class="line"></span><br><span class="line">가능한 작업들이 생기면 비동기 프로세스가 작업을 완료하여, 비동기적으로 처리한다.</span><br><span class="line"></span><br><span class="line">작업이 완료되면, 비동기 프로세스는 Completion Dispatcher 에게 정보를 넘기고 Dispatcher는 정보를 이벤트로 만들어서 적절한 Completion Handler 에게 발송한다.(Dispatch)</span><br><span class="line"></span><br><span class="line">Completion Handler는 받은 이벤트 정보를 토대로 정해는 콜백을 호출하여 Process Event를 처리한다.</span><br></pre></td></tr></table></figure><blockquote><p>Overlapped IO, IOCP가 이에 해당</p></blockquote><h1>Overlapped I/O</h1><blockquote><p>비동기 입출력과 비동기 통지를 결합하였다. IO을 충접치켜, 하나의 스레드에서 여러개의 IO처리를 가능하게 한다.</p></blockquote><ol><li><p>WSASend, WSARecv을 이용해 Overlapped IO 송수신하겠다고 우리가 커널에게 요청하면, OS가 송수신하고 우리에게 통지한다.</p></li><li><p>소켓 내부 버퍼를 사용하지 않더라도, 직접 TCP 전송 버퍼에서 데이터를 보내고 받을수 있다.</p></li></ol><h2>내부 버퍼를 사용하지 않다면?</h2><ol><li><p>수신시에는 TCP 수신버퍼에서 바로 가져올수 있도록, 충분한 수의 Overlapped IO 호출을 미리 해야된다.</p></li><li><p>송신시에는 사용자 버퍼량을 적당히 설정하고, TCP 송신 버퍼의 크기보다 크지않도록 설정해놓지 않으면, 사용자 버퍼의 내용이 TCP 송신버퍼에 다 복사될때까지, 사용자 버퍼를 쓰지못하기 때문에, 끊김 현상이 발생할수 있다.</p></li><li><p>데이터 전송이 완료되는 시점 이전까지 사용자 버퍼의 내용을 지우면 안된다.</p></li></ol><h2>장단점</h2><ul><li><p>장점<br>사용자가 지정한 버퍼로 바로 복사가 일어나기 때문에 데이터 복사 비용이 준다.</p></li><li><p>단점<br>멀티 스레드에 특화되지 않음.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Event 통지 패턴&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Select 모델은 Reactor 패턴이라고 볼수있다. 그에 반해, Overlapped IO, IOCP는 Proactor 패턴이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Reactor
      
    
    </summary>
    
    
      <category term="Winsock" scheme="https://Mutesk.github.io/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>Select 모델, ASyncSelect</title>
    <link href="https://Mutesk.github.io/2018/03/21/Select_Model/"/>
    <id>https://Mutesk.github.io/2018/03/21/Select_Model/</id>
    <published>2018-03-21T09:11:31.440Z</published>
    <updated>2018-03-21T09:37:32.548Z</updated>
    
    <content type="html"><![CDATA[<h1>Select 함수</h1><blockquote><p>제일 먼저 등장한 입출력 다중화 모델.</p></blockquote><p><em>예전에는 하나의 포트당 프로그램을 하나씩 동작하여 처리함. 하나의 프로세스에서 여러개의 디바이스 처리를 위해 등장</em></p><ol><li><p>블록킹 소켓 사용 효과</p><ul><li>소켓 함수 호출시, 조건 만족이 되지 않아서 블록되는 상황을 막는다.</li></ul></li><li><p>넌블록킹 소켓 사용 효과</p><ul><li>조건이 만족되지 않아서, 나중에 다시 호출하지 않아도 된다.</li></ul></li></ol><h2>Select 동작</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Select 모델을 사용하려면 소켓 셋 3개를 준비한다.</span><br><span class="line"></span><br><span class="line">소켓 셋은 읽기 셋, 쓰기 셋, 예외 셋으로 이루어져 있다.</span><br><span class="line"></span><br><span class="line">호출할 함수의 종류에 따라 소켓을 적당한 셋에 넣는다.</span><br><span class="line">소켓 셋 준비후, Select 호출하면, Select 함수는 소켓 셋에 포함된 소켓이 입출력을 위한 준비가 될때까지 대기한다.</span><br><span class="line"></span><br><span class="line">적어도 하나의 소켓이 준비되면 리턴, IO가 가능한 소켓만이 남는다.</span><br></pre></td></tr></table></figure><blockquote><p>IO완료를 통지받지 않고, Event Loop을 통해 소켓 상태를 검사하므로 동기식 입출력</p></blockquote><blockquote><p>타임아웃을 설정한 경우, 넘어가므로 논블록킹 소켓</p></blockquote><ul><li><p>장점</p><ul><li>모든 OS에서 지원하므로 이식성이 좋다.</li></ul></li><li><p>단점</p><ul><li>스레드당 처리가능한 소켓의 갯수가 정해져 있다. ( FD_SETSIZE로 처리가능한 수를 늘릴수 있음)</li><li>하위 호환성을 위해 존재한다. 소켓 입출력 모델중 가장 느리다. (소켓 상태를 다 검사해야된다.)</li></ul></li></ul><h2>Example</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">Client</span><br><span class="line">&#123;</span><br><span class="line">  ID, X, Y</span><br><span class="line">  SOCKET  <span class="comment">// 초기값 INVALID_SOCKET으로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Client g_client[<span class="number">30</span>];</span><br><span class="line">SOCKET g_ListenSocket;  <span class="comment">// 여기로 Accept 해주면 된다.</span></span><br><span class="line">ID = x(특정값);  <span class="comment">// 세션마다 고유한 번호를 매겨야 된다. -&gt; 쓰레드환경이면 중복값이 나올수 있다.</span></span><br><span class="line"><span class="comment">// 특정값부터 + 1씩 해나간다. (Unique한 값으로)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 서버 준비</span></span><br><span class="line">   <span class="comment">// Startup, Bind, 등등.. 네트워크 초기화 작업</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>()</span><br><span class="line">   &#123;</span><br><span class="line">     NetworkProcess()</span><br><span class="line">     Draw()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 이 소켓이 접속자인지 확인뒤 FD_SET에 넣는다.</span></span><br><span class="line">  FD_SET ReadSet;</span><br><span class="line">  Timeval time; <span class="comment">// 0,0</span></span><br><span class="line">  FD_ZERO(&amp;ReadSet);</span><br><span class="line">  FD_SET(g_ListenSocket, &amp;ReadSet);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="number">0</span>~<span class="number">29</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(접속자[n])</span><br><span class="line">    &#123;</span><br><span class="line">      FD_SET(접속자[n]소켓, &amp;ReadSet);</span><br><span class="line">      re = Select(<span class="number">0</span>, &amp;ReadSet, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;time);</span><br><span class="line">      <span class="keyword">if</span>(re &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(g_ListenSocket, &amp;ReadSet))</span><br><span class="line">        &#123;</span><br><span class="line">            Socket = Accept(g_ListenSocket, addr .... );</span><br><span class="line">            신규접속자처리(Socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="number">0</span> ~ <span class="number">29</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(접속여부 확인[N] &amp;&amp; FD_ISSET(소켓, &amp;ReadSet))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> packet[<span class="number">4</span>];</span><br><span class="line">      ret = recvn(소켓, packet, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0</span> || ret == SOCKET_ERROR)</span><br><span class="line">        접속해제(N);</span><br><span class="line">      패킷처리(N, Packet);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 함수</span><br><span class="line">신규접속자(Socket)</span><br><span class="line">&#123;</span><br><span class="line">  빈 클라이언트 구조체 탐색</span><br><span class="line">  Client[N].Socket = Socket;</span><br><span class="line">  [N].ID = g_ID++;</span><br><span class="line">  .X = ?</span><br><span class="line">  .Y = ?</span><br><span class="line"></span><br><span class="line">  Packet[<span class="number">1</span>].g_ID;</span><br><span class="line">  Packet[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  ret = Send(Socket, Packet, <span class="number">16</span> , <span class="number">0</span>);  <span class="comment">// ID 할당 파트</span></span><br><span class="line">  <span class="keyword">if</span>(ret == <span class="number">0</span> || ret == SOCKET_ERROR)</span><br><span class="line">    접속해제(N);</span><br><span class="line">  <span class="comment">// 신규 접속 파트</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="number">0</span> ~ <span class="number">29</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(Client[N] 확인)</span><br><span class="line">    &#123;</span><br><span class="line">      Packet[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      Packet[<span class="number">1</span>] = g_ID;</span><br><span class="line">      Packet[<span class="number">2</span>] = X</span><br><span class="line">      Packet[<span class="number">3</span>] = Y;</span><br><span class="line"></span><br><span class="line">      ret = Send(Socket, Packet, <span class="number">16</span> , <span class="number">0</span>);  <span class="comment">// ID 할당 파트</span></span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0</span> || ret == SOCKET_ERROR)</span><br><span class="line">        접속해제(N);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">접속해제(index)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 접속 해제 감지 방법 recv, send</span></span><br><span class="line">  CloseSocket(client[index].Socket);</span><br><span class="line">  Client[index] 초기화</span><br><span class="line">&#125;</span><br><span class="line">패킷처리(Index, packet)</span><br></pre></td></tr></table></figure><h1>ASyncSelect</h1><ul><li>소켓 함수 호출시 성공할수 있는 시점을 윈도우 메세지 수신으로 알수있다.</li></ul><blockquote><p>멀티스레드를 사용하지 않아도, 여러개의 소켓 처리가 가능(멀티스레드가 쓰기가 애매해진다.)</p></blockquote><blockquote><p>윈도우 메세지를 통해, 비동기적으로 소켓활용 가능</p></blockquote><ul><li><p>장점</p><ul><li>소켓 이벤트를 윈도우 메세지 형태로 처리하므로, GUI와 결합이 가능.</li></ul></li><li><p>단점</p><ul><li>하나의 윈도우 프로시저에서 일반 윈도우 메세지와 소켓 메세지를 처리해야하므로, 성능저하의 원인이 된다.</li><li>윈도우 큐 메세지에는 한도가 있다. 같이 쓰다보니, 오버플로우 될수 있다.</li><li>멀티스레드를 쓰기 힘든 구조</li></ul></li><li><p>유의할점</p><ul><li>WSAASyncSelect을 사용하면 해당 소켓은 자동으로 넌블럭킹 소켓</li><li>accpet 함수가 리턴하는 소켓은 연결대기 소켓과 동일한 속성을 갖게된다.<ul><li>연결대기 소켓은 데이터송수신 하지않으므로, FD_READ, FD_WIRTE를 처리하지 않는다.</li><li>다시 WSAASyncSelect 호출하여 이벤트를 등록해야된다.</li></ul></li><li>윈도우메세지를 받았을때, 소켓함수를 호출하지않으면, 다음번에는 윈도우메세지가 발생하지않는다.<ul><li>대응함수를 호출하거나, 직접 메세지를 발생시켜야 된다.</li></ul></li></ul></li></ul><h2>Example</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">WinMain()</span><br><span class="line">&#123;</span><br><span class="line">     Dialog IP 받기</span><br><span class="line">          <span class="comment">// Connect 하기전에 AsyncSelect를 해야된다.</span></span><br><span class="line">     <span class="comment">// 1. 소켓 생성</span></span><br><span class="line">     <span class="comment">// 2. 윈도우 생성</span></span><br><span class="line">     WSAASyncSelect(socket, hWnd, UM_MESSAGE, FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);</span><br><span class="line">     err = connect();</span><br><span class="line">     <span class="keyword">if</span>(WSAGetLastError() != WSAWOULDBLOCK)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 진짜 에러 -&gt; 종료</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// FD_CONNECT  신호가 오면 진짜로 연결된거다!. bConnect 플래그가 필요하다. FD_CONNECT가 뜨면 이 플래그를 TRUE로 전환한다.</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 메세지 루프</span></span><br><span class="line">     <span class="keyword">if</span>(bConnect)</span><br><span class="line">     &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WndProc()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">      <span class="keyword">if</span> 마우스 클릭중이라면</span><br><span class="line">        SendDraw(위치 전송);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UM_NETWORK:</span><br><span class="line">       에러 체크</span><br><span class="line">       <span class="keyword">switch</span>(이벤트 lParam)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">case</span> FD_CONNECT:</span><br><span class="line">            <span class="comment">// 진짜 연결 플래그 전환</span></span><br><span class="line">            bConnect = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">          <span class="comment">// 종료.</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FD_READ:</span><br><span class="line">          RecvEvent();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FD_WRITE: <span class="comment">// 첫 접속시, WSAWouldblock상태에서 전송가능상태로 전환된경우(버퍼가 비어질때)</span></span><br><span class="line">         SendFlag = <span class="literal">true</span>;</span><br><span class="line">         SendEvent();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendDraw(Sx, Sy, Ex, Ey)</span><br><span class="line">&#123;</span><br><span class="line">  SendQ에 넣기 작업</span><br><span class="line">  SendPacket(); <span class="comment">// SendQ에 있는 버퍼를 보내는 함수, FD_WRITE가 떳을때에도 이 함수를 호출한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendEvent() == SendEvent()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(SendFlag == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      WSABUF wsabuf[<span class="number">2</span>]</span><br><span class="line">      <span class="comment">// 셋팅</span></span><br><span class="line">     <span class="comment">// sendSize = 0으로 초기화</span></span><br><span class="line">      ret = WSAEvent(Socket, &amp;wsabuf, bufcount, &amp;sendSize, &amp;flag, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(ret == SOCKET_ERROR)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(WSAGetLastError() == WSAWOULDBLOCK)</span><br><span class="line">          &#123;</span><br><span class="line">            SendFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SendQ.Remove(SendSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RecvEvent()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> bufcount = <span class="number">1</span>;</span><br><span class="line">    WSABUF wsabuf[<span class="number">2</span>];</span><br><span class="line">    wsabuf[<span class="number">0</span>].len = 한방에 안끊기고 받을수 있는 사이즈</span><br><span class="line">    wsabuf[<span class="number">0</span>].buff = 쓰기에 대한 포인터</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(RecvQ.GetNotBrokenPutSize() &lt; RecvQ.GetFreeSize())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 아직 공간이 남았다면</span></span><br><span class="line">        wsabuf[<span class="number">1</span>].len = 길이</span><br><span class="line">        wsabuf[<span class="number">1</span>].buff = RecvQ의 시작 포인터</span><br><span class="line">        bufcount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD RecvSize = <span class="number">0</span>;  <span class="comment">// Out</span></span><br><span class="line">    DWORD Flag = <span class="number">0</span>;  <span class="comment">// In</span></span><br><span class="line">    ret = WSARecv(sock, &amp;wsabuf, <span class="number">2</span>, &amp;RecvSize, &amp;Flag, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 방법 1.</span></span><br><span class="line">    <span class="keyword">if</span>(ret == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// WSAGetLastError 체크</span></span><br><span class="line">        DWORD Error = WSAGetLastError();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Error != WSAWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">           끊기</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 방법 2.</span></span><br><span class="line">    <span class="keyword">if</span>(RecvSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 끊기</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RecvSize 크기만큼 m_rear 위치 변경</span><br><span class="line">    RecvQ.MoveWritePos(RecvSize);</span><br><span class="line">    PacketProc(); <span class="comment">// 패킷 처리 -&gt; 그리기</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PacketProc()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> len;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(RecvQ.GetUseSize() &lt; <span class="number">2</span>) <span class="comment">// 최소한 헤더 크기 이상</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      RecvQ.Peek(&amp;len, <span class="number">2</span>);  <span class="comment">// 헤더만큼 가져온다.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(RecvQ.GetUseSize() &lt; len + <span class="number">2</span>)   <span class="comment">// 사용한 데이터 &lt; 헤더 크기 + 2 라면 완성이 안되어있다.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      RecvQ.RemoveData(<span class="number">2</span>); <span class="comment">// 헤더만큼 큐에서 지운다.</span></span><br><span class="line">      RecvQ.Get(&amp;Packet, len);</span><br><span class="line">      Draw(-);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Select 함수&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;제일 먼저 등장한 입출력 다중화 모델.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;예전에는 하나의 포트당 프로그램을 하나씩 동작하여 처리함. 하나의 프로세스에서 여러개의 디바이스 처리를 
      
    
    </summary>
    
    
      <category term="Winsock" scheme="https://Mutesk.github.io/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>소켓 함수</title>
    <link href="https://Mutesk.github.io/2018/03/21/Socket_Programming/"/>
    <id>https://Mutesk.github.io/2018/03/21/Socket_Programming/</id>
    <published>2018-03-21T08:44:47.977Z</published>
    <updated>2018-03-21T09:11:13.804Z</updated>
    
    <content type="html"><![CDATA[<h1>논블록킹 소켓</h1><blockquote><p>소켓함수 호출시 조건이 만족되지 않아도 함수가 리턴한다.<br>ioctlsocket 함수로 소켓모드를 변경한다.</p></blockquote><h1>소켓함수</h1><h2>Accept</h2><p><em>접속한 클라이언트와 통신할수 있도록 새로운 소켓을 생성하여 리턴한다.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자 : LISTENING 상태인 소켓, 소켓 주소 구조체, 소켓주소 크기를 담은 정수형 변수의 포인터</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET s, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 성공: 새로운 소켓 리턴, 실패 : INVALID_SOCKET</span></span><br></pre></td></tr></table></figure><ul><li>블록킹<ul><li>새로운 연결이 없다면 블록된다.</li></ul></li><li>넌블록킹<ul><li>새로운 연결이 없으면 WOULDBLOCK 리턴한다.</li></ul></li></ul><h2>Connect</h2><p><em>서버와 논리적 연결을 설정한다.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자 : 서버와 통신용 소켓, 소켓 주소 구조체, 소켓 주소 구조체의 길이(바이트 단위)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(SOCKET s, <span class="keyword">const</span> struct sockaddr *name, <span class="keyword">int</span> namelen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 성공 : 0, 실패 : SOCKET_ERROR</span></span><br></pre></td></tr></table></figure><ul><li>블록킹<ul><li>실제 연결이 될때까지, 즉 SYN 에 대한 ACK을 받을때 까지, 블록된다.</li></ul></li><li>논블록킹<ul><li>에러 WOULDBLOCK을 리턴한다. UDP인 경우에는 바로 리턴된다.</li></ul></li></ul><h2>Send</h2><p><em>응용 프로그램 데이터를 운영체제의 송신버퍼에 복사함으로써 데이터를 전송한다.</em></p><p><em>Send 함수는 데이터 복사에 성공하면, 곧바로 리턴한다.</em></p><blockquote><p>따라서 Send함수가 실제 데이터를 전송하는것이 아니며, 일정시간이 지나야 전송된다.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자: 통신할 대상과 연결된 소켓, 보낼 데이터를 담는 응용프로그램의 버퍼 주소</span></span><br><span class="line"><span class="comment">// 보낼 데이터의 크기(바이트 단위), Send함수 동작을 바꾸는 옵션</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 성공: 보낸 바이트 수, 실패: SOCKET_ERROR</span></span><br></pre></td></tr></table></figure><ul><li><p>블록킹</p><ul><li>송신 버퍼의 여유공간이 Send() 함수의 세번째 인자 len보다 작은 경우, 해당 프로세스는 대기상태가 된다.</li><li>송신버퍼에 충분한 공간이 생기면 프로세스는 깨어나고, len크기만큼 데이터 복사가 일어나고 Send 함수가 리턴한다.</li></ul></li><li><p>넌블록킹</p><ul><li>송신버퍼의 여유만큼 데이터 복사한후, 실제복사한 바이트 수를 리턴한다. OS 송신버퍼에 공간이 없을때(부족할때), WOULDBLOCK을 리턴한다.</li></ul></li></ul><h2>Recv</h2><p><em>OS 수신버퍼에 도착한 데이터를 응용프로그램 버퍼에 복사한다.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 소켓, 받을 버퍼, 받을 데이터의 총 데이터량, Recv 동작 플래그</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET s, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 성공: 받은 데이터 수, 실패: SOCKET_ERROR</span></span><br></pre></td></tr></table></figure><ul><li>블록킹<ul><li>소켓 수신버퍼에 수신된 데이터가 없으면 프로세스는 Sleep 한다.</li></ul></li></ul><blockquote><p>데이터가 도착하면 (그것이 충분한 크기가 아니더라도) 깨어난다.</p></blockquote><ul><li>논블록킹<ul><li>수신버퍼가 비어 있을때 바로 WOULDBLOCK 리턴한다.</li></ul></li></ul><h2>기타 소켓함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket(); <span class="comment">// 사용자가 요청한 프로토콜을 이용해 통신할수 있도록 내부적으로 리소스 할당. 일종의 핸들인 소켓을 리턴</span></span><br><span class="line">bind(); <span class="comment">// 소켓의 지역 IP 주소와 지역 포트번호를 할당한다.</span></span><br><span class="line">listen(); <span class="comment">// 소켓의 TCP 포트 상태를 LISTENING 상태로 바꾼다.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;논블록킹 소켓&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;소켓함수 호출시 조건이 만족되지 않아도 함수가 리턴한다.&lt;br&gt;
ioctlsocket 함수로 소켓모드를 변경한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;소켓함수&lt;/h1&gt;
&lt;h2&gt;Accept&lt;
      
    
    </summary>
    
    
      <category term="Winsock" scheme="https://Mutesk.github.io/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>Game Server Programming 2</title>
    <link href="https://Mutesk.github.io/2018/03/19/GameServer1/"/>
    <id>https://Mutesk.github.io/2018/03/19/GameServer1/</id>
    <published>2018-03-19T10:08:21.350Z</published>
    <updated>2018-03-19T10:54:07.637Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#iocp">IOCP</a><ul><li><a href="#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC">동작원리</a><ul><li><a href="#iocp-%EC%83%9D%EC%84%B1">IOCP 생성</a></li><li><a href="#io%EC%9E%A5%EC%B9%98%EC%99%80-iocp-%EC%97%B0%EA%B2%B0">IO장치와 IOCP 연결</a></li></ul></li><li><a href="#io-completion-queue">IO Completion Queue</a></li></ul></li><li><a href="#page-lock">Page-Lock</a></li><li><a href="#non-paged-pool">Non-Paged Pool</a><ul><li><a href="#non-paged-pool%EC%9D%98-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0">Non-Paged Pool의 사용되는 경우</a></li><li><a href="#zero-byte-recv">Zero Byte Recv</a></li><li><a href="#so_rcvbuf-so_sndbuf">SO_RCVBUF, SO_SNDBUF</a></li></ul></li><li><a href="#thread">Thread</a><ul><li><a href="#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">멀티스레드 프로그램을 사용하는 이유</a></li><li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0">스레드를 사용하면 안되는 경우</a></li><li><a href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC">스케쥴러</a><ul><li><a href="#%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98">문맥교환</a></li><li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%83%81%ED%83%9C">스레드 상태</a><ul><li><a href="#running">Running</a></li><li><a href="#ready">Ready</a></li><li><a href="#block--suspended">Block / Suspended</a></li></ul></li></ul></li><li><a href="#%EC%B5%9C%EC%86%8C-%EB%8B%A8%EC%9C%84-%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%EC%85%98-atomic-operation">최소 단위 오퍼레이션 (Atomic Operation)</a></li><li><a href="#%EC%83%81%ED%98%B8-%EB%B0%B0%EC%A0%9C">상호 배제</a></li><li><a href="#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C">교착 상태</a></li><li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%97%AD%ED%95%99">스레드 역학</a></li><li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%B0%A9%EB%B2%95">스레드 동기화 방법</a><ul><li><a href="#interlocked-%EA%B3%84%EC%97%B4">Interlocked 계열</a></li></ul></li><li><a href="#critical-section">Critical Section</a><ul><li><a href="#spin-lock">Spin Lock</a></li><li><a href="#waitforsingleobject-waitformultipleobject">WaitForSingleObject, WaitForMultipleObject</a></li><li><a href="#mutex">Mutex</a><ul><li><a href="#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-1">동작원리</a></li></ul></li><li><a href="#event">Event</a><ul><li><a href="#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-2">동작원리</a></li></ul></li></ul></li></ul></li></ul><!-- /TOC --><h1>IOCP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">커널 객체로써, 입출력 완료 포트(I/O Completion Port)이다.</span><br><span class="line">특수한 목적으로 사용되며, 한정적인 객체.</span><br><span class="line">프로세스 사이에서 IOCP 객체 공유는 불가능하며, 윈도우에서 제공하는 비동기 입출력을 위한 훌륭한 메커니즘이다.</span><br><span class="line">IOCP는 입출력 완료에 대한 처리를 수행할 스레드를 몇 개 미리 생성하여 스레드 풀을 구성한 후, 입출력 완료 시마다 스레드 풀의 임의의 스레드를 출어서 끄집어 내 완료 후의 처리를 담당하게 한다.</span><br></pre></td></tr></table></figure><ul><li><p>참고로 스레드는 디폴트로 1M의 스레드 스택을 가진다. 또한 스레드 문맥을 비록하여 자체 정보를 담기 위해 메모리를 소비한다.</p></li><li><p>IOCP는 가장 큰 특징은 요구사항을 처리해주는 스레드의 수를 제한할수 있다.</p></li><li><p>IOCP는 스레드를 적극적으로 활용하기 위해 만들어졌다.</p></li><li><p>IOCP는 기본적으로 스레드 풀의 형성이고, 따라서 최소 몇 개의 스레드를 전제하고 있다.</p></li></ul><h2>동작원리</h2><h3>IOCP 생성</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateIoComepletionPort(</span><br><span class="line">       HANDLE FileHandle,      <span class="comment">// IOCP 연결할 핸들</span></span><br><span class="line">       </span><br><span class="line">       HANDLE ExistingCompletionPort,  <span class="comment">// IOCP 핸들 없다면 NULL</span></span><br><span class="line">       ULONG_PTR   CompletionKey,      <span class="comment">// IO 완료시 넘어갈 값, 사용자가 넘기고싶은값을 넘김.</span></span><br><span class="line">       DWORD   NumberOfConcurrentThread      <span class="comment">// 한번에 동작할수 있는 최대 스레드 수, 0을 넣으면 자동으로 최적의 값을 넣어준다. </span></span><br><span class="line">       );</span><br></pre></td></tr></table></figure><h3>IO장치와 IOCP 연결</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);        <span class="comment">// IOCP Handle</span></span><br><span class="line">HANDLE Port = CreateIoCompletionPort(</span><br><span class="line">    socket, hPort, (ULONG_PTR)id, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>두번째 CreateIoCompletionPort를 호출하면서  IOCP 장치리스트에 새로운 레코드를 추가한다.</p></li><li><p>삭제할 시점은 해당 장치의 핸들이 닫혔을때 이다.(위는 소켓을 썻으니 closesocket을 호출시켜야 된다.)</p></li></ul><h2>IO Completion Queue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">이 큐는 IOCP와 연결한 Device의 IO 작업이 끝났음을 알려주는 큐이다.</span><br><span class="line"></span><br><span class="line">스레드에서 IO Completion Queue에서 작업거리르 꺼내 IO완료에 따른 처리를 수행하게 한다.</span><br><span class="line"></span><br><span class="line">GetQueuedCompletionStatus 함수를 호출 했을때, 당장 IO Comepletion Queue에 항목이 없거나 동시 수행 가능한 스레드 개수를 초과한 경우 대기 큐에 들어가 대기하고 있다가 상황이 오면 IO완료에 대한 처리를 수행하게 한다.</span><br></pre></td></tr></table></figure><h1>Page-Lock</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WSASend, WSARecv 의 경우 상황에 따라 제공된 버퍼가 페이징 되지 않도록 Lock을 걸게 된다.</span><br><span class="line"></span><br><span class="line">WSASend의 경우 소켓 버퍼가 가득찰 경우, </span><br><span class="line">WSARecv의 경우 소켓버퍼로 부터 받을 데이터가 없을 경우일 것.</span><br><span class="line"></span><br><span class="line">OS는 이렇게 잠겨진 메모리의 한계를 정의하고 있으며, 이 한계를 넘어가면 WSAENOBUFS로 Overlapped I/O는 실패하고 만다. 또 이렇게 전달된 유저 버퍼는 페이지 단위로 Lock를 걸게 된다. 1KB의 버퍼를 WSARecv 의 인자로 전달 했다면 OS는 4KB만큼 메모리를 잠근다는 뜻이다.</span><br><span class="line"></span><br><span class="line">메모리 낭비를 줄이기 위해서는 버퍼를 페이지 단위(4KB의 배수)로 잡는것이 효율적이다.</span><br></pre></td></tr></table></figure><h1>Non-Paged Pool</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page-Locking이 일반 메모리를 페이징 안되도록 막는 개념이라면, Non-Paged Pool은 애초부터 물리 메모리에 상주하여 페이징이 안되도록 만들어놓은 영역이다. </span><br><span class="line"></span><br><span class="line">Page-Fault가 없다보니 접근 속도도 빠르며 고레벨 IRQL(Interrupt Request Level) 접근이 오류 없이 가능해진다. 그렇다보니 드라이버나 프로그렘들이 Non-Paged Pool을 남용하여 사용하게 되고, 제한된 리소스는 손쉽게 고갈되어 문제가 발생한다.</span><br><span class="line"></span><br><span class="line">보통 Non-Paged Pool은 Windows 2000이상의 버전에서는 물리메모리의 1/4가 한계이다.</span><br><span class="line"></span><br><span class="line">부족해지면 윈속함수에서 에러가 나오거나 운이 좋지않다면 시스템 에러로 손상될수 있다.</span><br></pre></td></tr></table></figure><h2>Non-Paged Pool의 사용되는 경우</h2><ol><li>드라이버와 같은 커널모드 컴포넌트에서 사용. WinSock, TCPIP.sys와 같은 프로토콜 드라이버도 이에 속함.</li><li>소켓을 생성할때마다 소켓의 상태 정보를 저장하기 위한 용도로도 작은 양의 Non-Paged Pool 소비한다.</li><li>소켓이 특정 주소로 바인딩되면, TCP/IP 스택은 로컬 주소 정보를 저장하기 위한 용도로도 Non-Paged Pool을 할당한다.</li><li>Overlapped I/O 연산시 IRP(I/O Request Packet)을 발생시키면서 약 500 바이트의 Non-Paged Pool 할당한다.</li></ol><h2>Zero Byte Recv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page Locking 최소화하기 위해 하는 방법.</span><br><span class="line"></span><br><span class="line">일단 Overlapped I/O 작업이 일어나면 Page-Locking + Non-Paged Pool의 소비는 필수적이다. </span><br><span class="line"></span><br><span class="line">0 바이트를 읽는 Recv 작업을 보내는 기법인데, 일단 읽는 크기가 0바이트이기 때문에 Page-Locking이 일어나지 않는다.</span><br><span class="line"></span><br><span class="line">IOCP는 Proactor 방식이기 때문에 실제 읽기 작업이 일어나지 않고 있어도  WSARecv하고 있어야 하고, 이 때문에 메모리가 아무 작업도 안하는데 Page-Locking이 될수 있다는 걸 생각해보면 Zero Byte Recv가 굉장히 효율적인 방식이 될수 있다.</span><br></pre></td></tr></table></figure><h2>SO_RCVBUF, SO_SNDBUF</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">송수신 버퍼 크기를 0으로 지정한다면, 커널 레벨에서의 송수신 버퍼를 이용하지 않고, App으로 바로 복사가 일어나므로 복사 횟수는 한번 줄어들고 속도도 굉장히 빨라진다. 물론 버퍼로의 직접 복사 때문에 Page-Locking은 일어난다. (이 방법의 문제는 Recv에서는 문제가 있다. 못받는 틈이 존재하게 됨.)</span><br></pre></td></tr></table></figure><h1>Thread</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">멀티스레드 프로그래밍이란 간단히 말해서 동일한 애플리케이션 안에서 두 갱 ㅣ상의 기능이 병렬적으로 수행될수 있도록 소프트웨어를 작성한다.</span><br><span class="line"></span><br><span class="line">주의 깊게 작성한 멀티스레드 프로그램은 일반적으로 수행 시간, 사용자 응답성, 프로그램 구조 중 적어도 하나 이상은 싱글스레드 프로그램보다 우수하다.</span><br><span class="line"></span><br><span class="line">운영체제의 규칙에 대해서 정확히 파악하고 있어야 한다.</span><br></pre></td></tr></table></figure><h2>멀티스레드 프로그램을 사용하는 이유</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">병렬화의 증가, 빠른 처리, 향상된 안정성, 사용자에 대한 향상된 응답성, CPU 사용률의 증가</span><br></pre></td></tr></table></figure><h2>스레드를 사용하면 안되는 경우</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeadLock, Stravation(기아현상)을 발생시킬수 있는 요인이 있다.</span><br></pre></td></tr></table></figure><ul><li><p>확실한 이유를 가지고 있지 않은 경우에는 스레드를 사용하면 안된다.( 두 개의 스레드가 명확하게 독립적이지 않은 경우에는 하나의 작업을 둘로 나누면 안된다.)</p></li><li><p>스레드에 의한 작업의 빈도를 고려할 때, 운영체제가 스레드 스케쥴링을 하고 스레드를 다루는 데 발생하는 부하(Overhead)가 실제 스레드에 의해 수행된느 작업량보다 클 경우에는 스레드를 사용하면 안된다.</p></li></ul><h2>스케쥴러</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows는 모든 스레드를 Round Robin 형태로 스케쥴링한다.</span><br><span class="line"></span><br><span class="line">현재 스레드를 수행을 중지시키고 새로운 스레드를 수행시키기 위해서 운영체제는 문맥 교환을 한다.</span><br><span class="line"></span><br><span class="line">각각 의 스레드 안에는 TCB(스레드 문맥 블록 : Thread Context Block)이 있고  이 안에는 PCB(Process Context Block)의 포인터가 있다. </span><br><span class="line"></span><br><span class="line">문맥 블록은 기본적으로 스레드가 지난번에 CPU에서 동작했을때의 레지스터 값의 스냅샷을 나타낸다.</span><br></pre></td></tr></table></figure><p><img src="P0.png" alt="스레드 상태 전이"></p><h3>문맥교환</h3><ol><li><p>스케쥴러가 같은 프로세스 안에서 동작하는 두 개의 스레드의 문맥 교환을 하는 경우.</p></li><li><p>스케쥴러가 다른 프로세스에서 동작하는 두 개의 스레드의 문맥 교환을 하는 경우. 같은 프로세스 안에서 문맥교환 하는것보다 큰 비용이 소모된다.</p></li></ol><h3>스레드 상태</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">시스템의 모든 스레드는 기본적으로 세 가지 상태 중 한가지에 속한다.</span><br></pre></td></tr></table></figure><h4>Running</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">수행 중인 스레드는 컴퓨터의 CPU에서 현재 스레드의 코드가 수행되고 있는 스레드를 의미한다.</span><br></pre></td></tr></table></figure><h4>Ready</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">현재 수행 중인 스레드는 아니지만 운영체제가 CPU에게 시간을 할당하면 바로 수행 할수 있는 스레드를 준비상태에 있다고 한다.</span><br></pre></td></tr></table></figure><h4>Block / Suspended</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">세마포어 같은 커널 객체가 Signaled 되거나 I/O 동작이 끝나기를 대기하는 스레드를 블록된 상태라고 한다.Sleep이나 SuspendThread 같은 시스템 콜을 사용하게 되면 OS에 의해 잠깐동안 보류될수 있다.</span><br></pre></td></tr></table></figure><h2>최소 단위 오퍼레이션 (Atomic Operation)</h2><ul><li>기본적으로는 에섬코드 1줄이라고 봐도 무방하다. (완벽하진 않음.)</li><li>스레드 디버깅 = 어셈블리 코드를 보고 Sync가 깨질만한 요소를 찾아야 된다.</li><li>최대한 락을 안걸고 쓰기 위해서는 디스어셈블리를 봐야됨.</li></ul><h2>상호 배제</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">최소 수행 단위를 넘어서는 길이의 동작을 인터럽트 되지 않고 수행해야 할 필요가 발생한다.</span><br><span class="line">이럴경우 데이터 구조나 코드 영역에 대한 상호 배타적인 접근만을 허용하기 위해서 동기화 도구를 사용하게 되는데 이걸 상호 배제라고 함. (뮤텍스, 세마포어 동기화 객체를 이용해서 락을 건다.)</span><br></pre></td></tr></table></figure><h2>교착 상태</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeadLock 상태. 서로 자기 자원을 가지고 있고 상대방 스레드에 있는 자원을 서로 요구하면 무한적 락이 걸린다.</span><br></pre></td></tr></table></figure><ol><li><p>다수 자원에 대한 소유와 대기(Hold And Wait For Multiple Resource)</p><ul><li>적어도 하나의 스레드는 자원에 대한 소유권을 갖고 있어야 하고, 다른 스레드에 의해 소유된 공유 자원을 획득하려고 해야 함.</li></ul></li><li><p>상호 배체(Mutual Exclusion)</p><ul><li>자원의 소유권은 반드시 한번에 하나의 스레드에게 만 허용되어야 함.</li></ul></li><li><p>무선점(No Preemption)</p><ul><li>운영체제가 다른 스레드에게 공유 자원에 대한 소유권을 주기 위해서 이미 공유 자원을 소유하고 있는 스레드의 소유권을 뺏을수 없다.</li></ul></li><li><p>순환 대기(Circular Wait)</p><ul><li>둘 이상의 스레드가 순환 대기를 발생하는 형태로 자원에 대해 대기하고 있어야 한다.</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">위의 4가지 조건이 동시에 모두 발생하지 않는다면, 교착상태는 발생하지 않는다.</span><br></pre></td></tr></table></figure><h2>스레드 역학</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">생성 - CreateThread(스레드 핸들 리턴)</span><br><span class="line">임의적인 쓰레드 스택 크기도 지정가능 (기본 1메가)</span><br><span class="line">스레드 안은 무한 루프를 통해 중지하지 않고 계속 돌리게한다.</span><br><span class="line">함수 포인터를 써서 스레드를 지정.</span><br><span class="line">스레드 종료 코드 가 0 -&gt; 우리가 메인에 return 0 한것과 같음.</span><br><span class="line"></span><br><span class="line">스레드 참조 카운터가 0이 되면 실제로 스레드가 파괴된다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, 스레드 함수 주소, 함수 파라메터, 플래그, 스레드 ID(Out) )</span><br><span class="line"></span><br><span class="line">GetCurrentHandle() <span class="comment">// 가상 핸들을 리턴한다. (CloseHandled 되지 않으며 참조 카운트도 증가하지 않음.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 스레드에서 제일 좋은건 리턴시키는것. ExitThread -&gt; Return과 같음. , TerminateThread -&gt; 강제중단 , 메모리 해제도 안됨.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 우리는 _beginthreadex, _endthreadex만 사용할것임. process.h를 헤더에 추가.</span></span><br></pre></td></tr></table></figure><h2>스레드 동기화 방법</h2><h3>Interlocked 계열</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">보통 Lock이라고 하지 않음. 특정 변수에 대한 안전한 동기화</span><br><span class="line">인터록 계열은 동기화 객체를 사용하지 않고, 안전하게 처리해준다. ( 함수는 아니다. 바로 어셈블 코드로 넘어간다.)</span><br><span class="line"></span><br><span class="line">뮤텍스, 세마포어, 이벤트와 동일하게 Enter하고 Leave하는 방식.</span><br><span class="line">인터록 함수는 대상 변수에 대해 동일하게 인터록를 써줘야 한다.</span><br></pre></td></tr></table></figure><h2>Critical Section</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">상호 배제를 구현하기 위해서 임계영역을 사용한다. 임계영역은 한번에 하나의 스레드만이 들어갈수 있다.</span><br><span class="line"></span><br><span class="line">유저 객체이기 때문에, 커널 객체인 뮤텍스, 세마포어, 이벤트 보단 빠르다.</span><br><span class="line">객체 자체는 커널 객체는 아니지만, 동기화 행위는 유저 모드에서 할수 없다.</span><br><span class="line"></span><br><span class="line">다른 스레드가 임계영역에 들어오지 않았다면, 다른 동기화모드보다 효율적이다.</span><br><span class="line"> = 만약 이 상황이 아니라면 인터록모드로 처리한다.</span><br><span class="line"></span><br><span class="line"> 같은 스레드에 의해 재귀적으로 계속 획득할수 있다. Enter, Leave 카운팅은 정확해야 된다.</span><br><span class="line"></span><br><span class="line"> 동기화가 들어가지 않는다면 카운팅밖에 없기 때문에, 거의 속도에 영향을 주지 않는다.</span><br><span class="line"> = 2개 이상의 스레드가 대기중이라면 누가 먼저 처리될지는 모른다.</span><br><span class="line"></span><br><span class="line">락카운트, 해제 카운트, 락 세마포어, 점유중인 스레드 스핀 카운트로 구성되어 있다.</span><br></pre></td></tr></table></figure><h3>Spin Lock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">일반적으로 Lock 거는 곳에서 CPU 자원을 소비하면서 무한 루프를 돌려 락을 요청한다.</span><br><span class="line">    =&gt; 커널모드로 전환, 대기 스레드에 넣고 다시 깨어나는 Overhead의 낭비를 줄이기 위해서다. (그 만큼 CPU 사용량이 증가한다.) Lock Free 구조와 비슷하다.</span><br></pre></td></tr></table></figure><h3>WaitForSingleObject, WaitForMultipleObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">커널 동기화 객체들은 이 함수를 통해서 락을 건다. 모든 커널 객체는 Signaled, NonSignaled 상태로 나뉘어진다.</span><br><span class="line"></span><br><span class="line">Signaled 상태라면 , 이함수를 통해 깨어난다.</span><br><span class="line">NonSignaled 상태라면, 이 함수를 통해 잠든다.</span><br><span class="line"></span><br><span class="line">프로세스 객체 Signaled = 프로그램이 종료되었을때</span><br><span class="line">쓰레드 객체 Signaled = 스레드가 종료되었을때</span><br><span class="line">!!이벤트 객체 Signaled = SetEvent와 PulseEvent 함수에 따라 조절된다.</span><br><span class="line">뮤텍스 객체 Signaled = 뮤텍스 객체가 어떤 스레드도 가지고 있지 않을때 (스레드는 ReleaseMutex로 소유포기가능)</span><br><span class="line">세마포어 - 뮤텍스와 비슷하지만 카운팅을 한다. =&gt; 몇명이 소유할수 있는가를 컨트롤한다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(HANDLE, 대기시간)</span><span class="comment">// =&gt; 우리는 이벤트로 많이 쓸것. 리턴이 WAIT_OBJECT_0 이면 정상</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObject</span><span class="params">(핸들 숫자, 핸들 배열 포인터, 전부 대기 Flag, 대기 시간)</span></span>;</span><br><span class="line"><span class="comment">// 배열의 인덱스가 앞에 있는 것 부터 순차적으로 확인한다. 즉 Signaled 빈도가 높은 스레드는 가장 뒤에 넣어준다.</span></span><br><span class="line"><span class="comment">// 안그러면 뒷 스레드가 처리되지 않거나 무시된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return WAIT_OBJECT_0 ~ WAIT_OBJECT_0 + nCount - 1;</span></span><br></pre></td></tr></table></figure><h3>Mutex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">가장 일반적으로 사용되는 동기화 커널 객체</span><br><span class="line">임계 영역과 달리 서로 다른 프로세스에 속한 세르드가 동일 자원에 대해서 접근하는 경우에도 동기화하는데 사용할수 있다.</span><br></pre></td></tr></table></figure><h4>동작원리</h4><ol><li>생성</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR)</span></span>; <span class="comment">// 보안속성, 해당 함수 호출 스레드도 포함여부, 뮤텍스 객체 이름을 나타내는 문자열 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 성공 : 뮤텍스 핸들</span></span><br><span class="line"><span class="comment">// 실패 : NULL</span></span><br></pre></td></tr></table></figure><ol start="2"><li>이미 생성된 뮤텍스의 핸들 확보 또는 뮤텍스가 존재하지 않은 경우 뮤텍스를 생성하지 않기를 원할때(검색)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenMutex</span><span class="params">(DWORD dwDesiredAccess, BOOL InheritHandle, LPCTSTR lpName)</span></span>;</span><br><span class="line"><span class="comment">// lpName이름의 뮤텍스를 가지려는 스레드의 접근 형태를 나타내는 비트 플래그</span></span><br><span class="line"><span class="comment">// 이 함수를 호출하는 프로세스가 CreateProcess 함수를 사용한 경우 핸들이 새로 생성된 프로세스에 상속 가능한지 나타냄. </span></span><br><span class="line"><span class="comment">// 열려고 하는 뮤텍스의 이름을 나타냄</span></span><br></pre></td></tr></table></figure><ol start="3"><li>뮤텍스 해제</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseMutex</span><span class="params">(HANDLE hMutex)</span></span>;</span><br></pre></td></tr></table></figure><h3>Event</h3><pre><code>스레드를 외부에서 제어(자동모드와 수동모드가 있다.)Signaled 신호를 없앨때 이를 자동으로 할지 수동으로 할지 정하는것.자동일 경우 작업을 끝낸뒤에 없애버린다. 또한 이경우 SetEvent, ResetEvent를 쓰지 않는게 좋다.수동일 경우 SetEvent, ResetEvent를 무조껀 써야 한다.-&gt; 우리는 대부분 메뉴얼모드를 종료용으로 쓸것이다.</code></pre><h4>동작원리</h4><ol><li>생성</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(보안기술, 메뉴얼리셋, 초기상태, 이름)</span></span>;</span><br><span class="line"><span class="comment">// 2번재 인자 : TRUE 수동리셋 이벤트, FALSE: 자동리셋 이벤트</span></span><br><span class="line"><span class="comment">// 3번째 인자 : 이벤트 객체의 초기 상태를 지정하는 플래그</span></span><br><span class="line"><span class="comment">// 4번째 인자 : 이벤트 객체이름</span></span><br></pre></td></tr></table></figure><ol start="2"><li>검색</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenEvent</span><span class="params">(DWORD dwDesiredAccess, BOOL InHeritHandle, LPCSTR lpName)</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>이벤트 객체를 Signaled화</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(HANDLE hEvent)</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>이벤트 객체를 NonSingaled</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(HANDLE hEvent)</span></span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>이벤트 객체가 대기중이라면 시그널상태로 바꿔준다.\</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PulseEvent</span><span class="params">(HANDLE hEvent)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#iocp&quot;&gt;IOCP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC&quot;&gt;동작원리&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#iocp-%EC
      
    
    </summary>
    
    
      <category term="Windows API, MultiThread, GameServer" scheme="https://Mutesk.github.io/tags/Windows-API-MultiThread-GameServer/"/>
    
  </entry>
  
  <entry>
    <title>Game Server Programming 1</title>
    <link href="https://Mutesk.github.io/2018/03/19/GameServer0/"/>
    <id>https://Mutesk.github.io/2018/03/19/GameServer0/</id>
    <published>2018-03-19T10:08:16.412Z</published>
    <updated>2018-03-19T10:54:00.305Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#game-server-programming-1">Game Server Programming 1</a><ul><li><a href="#osi-7%EA%B3%84%EC%B8%B5-tcpip-4-%EA%B3%84%EC%B8%B5">OSI 7계층, TCP/IP 4 계층</a><ul><li><a href="#osi-7%EA%B3%84%EC%B8%B5">OSI 7계층</a></li><li><a href="#tcpip-4-%EA%B3%84%EC%B8%B5">TCP/IP 4 계층</a></li></ul></li><li><a href="#tcpudp%EC%9D%98-%EC%B0%A8%EC%9D%B4">TCP/UDP의 차이</a><ul><li><a href="#udpuser-diagram-protocal">UDP(User Diagram Protocal)</a></li><li><a href="#tcptransmission-control-protocal">TCP(Transmission Control Protocal)</a></li></ul></li><li><a href="#capsulation-and-uncapsulation%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%9D%90%EB%A6%84">Capsulation and UnCapsulation(네트워크 흐름)</a></li><li><a href="#tcp-review">TCP Review</a><ul><li><a href="#nagle-algorithm">Nagle Algorithm</a></li><li><a href="#tcp-disconnect-%EA%B0%90%EC%A7%80">TCP Disconnect 감지</a><ul><li><a href="#%EC%9C%A0%EB%A0%B9%EC%84%B8%EC%85%98">유령세션</a></li><li><a href="#keepalive">KeepALive</a></li><li><a href="#heartbeat">HeartBeat</a></li></ul></li><li><a href="#%EC%86%8C%EC%BC%93-%EC%98%B5%EC%85%98">소켓 옵션</a><ul><li><a href="#so_keepalive">SO_KEEPALIVE</a></li><li><a href="#so_linger">SO_LINGER</a><ul><li><a href="#closesocket">closesocket()</a></li><li><a href="#shutdown">shutdown()</a></li></ul></li><li><a href="#so_sndbuf-so_revbuf">SO_SNDBUF, SO_REVBUF</a></li><li><a href="#so_sndtimeo-so_rcvtimeo">SO_SNDTIMEO, SO_RCVTIMEO</a></li><li><a href="#so_reuseaddr">SO_REUSEADDR</a></li></ul></li><li><a href="#tcp-connect3-way-handshake">TCP Connect(3 Way HandShake)</a></li><li><a href="#graceful-shutdown4-way-handshake">GraceFul Shutdown(4 Way HandShake)</a></li></ul></li><li><a href="#io-event-notification-modelr">I/O Event Notification Modelr</a><ul><li><a href="#synchronous">Synchronous</a></li><li><a href="#asynchronous">ASynchronous</a></li><li><a href="#blocking">Blocking</a></li><li><a href="#nonblocking">NonBlocking</a></li><li><a href="#io-event-%ED%86%B5%EC%A7%80-%EB%AA%A8%EB%8D%B8%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0">I/O Event 통지 모델이 필요한 이유</a></li></ul></li><li><a href="#select-%EB%B0%A9%EC%8B%9D">SELECT 방식</a><ul><li><a href="#posix-%ED%91%9C%EC%A4%80">POSIX 표준</a><ul><li><a href="#%EC%9E%A5%EB%8B%A8%EC%A0%90">장단점</a></li></ul></li><li><a href="#select-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%86%B5%EC%A7%80-%EB%B0%A9%EC%8B%9D">SELECT 모델의 이벤트 통지 방식</a></li></ul></li><li><a href="#windows-io-%ED%86%B5%EC%A7%80-%EB%AA%A8%EB%8D%B8">Windows I/O 통지 모델</a><ul><li><a href="#wsaasyncselect">WSAASyncSelect</a></li><li><a href="#overlapped-io-callback">Overlapped I/O CallBack</a><ul><li><a href="#%EC%9E%A5%EB%8B%A8%EC%A0%90-1">장단점</a></li></ul></li></ul></li></ul></li><li><a href="#wsa-%EC%86%8C%EC%BC%93-%EC%97%90%EB%9F%AC-%EC%A0%95%EB%A6%AC">WSA 소켓 에러 정리</a><ul><li><a href="#wsa_wouldblock">WSA_WOULDBLOCK</a></li><li><a href="#wsa_io_pending">WSA_IO_PENDING</a></li></ul></li><li><a href="#%EB%8F%84%EB%A9%94%EC%9D%B8dns-server">도메인(DNS Server)</a><ul><li><a href="#ddns-dynamic-dns">DDNS (Dynamic DNS)</a></li></ul></li><li><a href="#%ED%99%80-%ED%8E%80%EC%B9%ADnat-%ED%88%AC%EA%B3%BC">홀 펀칭(NAT 투과)</a></li></ul><!-- /TOC --><h2>OSI 7계층, TCP/IP 4 계층</h2><h3>OSI 7계층</h3><table><thead><tr><th style="text-align:center">Level</th><th style="text-align:center">계층 / 기능</th></tr></thead><tbody><tr><td style="text-align:center">Application</td><td style="text-align:center">응용 계층 : 사용자가 네트워크에 접근할수 있도록 해주는 계층</td></tr><tr><td style="text-align:center">Presentation</td><td style="text-align:center">표현 계층: 운영체제의 한 부분, 입력 또는 출력되는 데이터를 하나의 표현 형태로 변환한다. 전송 데이터를 서로 이해할수 있도록 한다.</td></tr><tr><td style="text-align:center">Session</td><td style="text-align:center">세션 계층 : 통신 세션을 구성하는 계층 , 포트(Port) 연결이라고 할수 있다. 통신장치 간의 상호작용을 설정하고, 유지하고 동기화한다.</td></tr><tr><td style="text-align:center">Transport</td><td style="text-align:center">전송 계층: 전체 메시지를 발신지 대 목적지간 제어와 에러를 관리한다.</td></tr><tr><td style="text-align:center">Network</td><td style="text-align:center">다중 네트워크 링크에서 패킷을 발신지로부터 목적지로 전달할 책임을 갖는다.</td></tr><tr><td style="text-align:center">Data-Link</td><td style="text-align:center">데이터링크 계층: 오류없이 한 장치에서 다른장치로 Frame(비트의 모음)전달하는 역할. 3계층에서 정보를 받아 주소와 제어정보를 시작와 끝에 추가한다.(Mac Address)</td></tr><tr><td style="text-align:center">Physical</td><td style="text-align:center">물리적 매체를 통해 Bit 흐름을 전송하기 위해 요구되는 기능들을 조정한다.</td></tr></tbody></table><h3>TCP/IP 4 계층</h3><table><thead><tr><th style="text-align:center">레벨</th><th style="text-align:center">계층 / 기능</th></tr></thead><tbody><tr><td style="text-align:center">Application</td><td style="text-align:center">응용 계층 : OSI 의 5,6,7 계층이 해당된다. TCP/IP 기반의 응용프로그램 구분할떄 사용된다.</td></tr><tr><td style="text-align:center">Transport</td><td style="text-align:center">전송 계층: OSI의 4계층. 통신 노드간의 연결 제어. 자료 송수신을 담당한다.</td></tr><tr><td style="text-align:center">Internet</td><td style="text-align:center">인터넷 계층 : OSI 의 3계층. 통신 노드 간의 IP 패킷을 전송하는 기능 및 라우팅 기능을 담당한다.</td></tr><tr><td style="text-align:center">Network Interface</td><td style="text-align:center">네트워크 인터페이스 계층: OSI 7계층의 1,2 계층. CSMA/CD, MAC, LAN, X.25 등 전송에 사용된다.</td></tr></tbody></table><h2>TCP/UDP의 차이</h2><h3>UDP(User Diagram Protocal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">경량 프로토콜로써 데이터를 포장하여 호스트의 어떤 포트에서 다른 호스트의 또 어떤 포트로 전달하는데 쓴다.</span><br></pre></td></tr></table></figure><ul><li>딱 헤더만 있으면 된다.</li><li>비 신뢰성</li><li>릴 라이어블 UDP(우리가 만든다.)를 만든다. -&gt; UDP는 빠른데 안가면 다시 가게 만든다.</li><li>1:1, 1:M, N:M</li><li>Datagram</li><li>순서 보장하지 않음.</li></ul><h3>TCP(Transmission Control Protocal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">양쪽 호스트 사이에 연결을 계속 유지한 채로 신뢰성 있게 데이터의 스트림을 주고 받을수 있다.</span><br><span class="line">핵심은 신뢰성(Reliable) 하다.</span><br></pre></td></tr></table></figure><ul><li>홀 펀칭이 힘들다.</li><li>오류 확인, 상태 플래그</li><li>신뢰성(Reliable)</li><li>1:1</li><li>Stream</li><li>순서 보장</li></ul><h2>Capsulation and UnCapsulation(네트워크 흐름)</h2><p><img src="P0.png" alt="패킷 전달 과정"></p><h2>TCP Review</h2><h3>Nagle Algorithm</h3><p>패킷의 크기를 최대 세그먼트 길이에 가능한 한 가깝게 맞추어 네트워크 혼잡을 줄이는 기법.</p><p>이미 전송 중인(ACK을 아직 못받음) 데이터가 있을때 이후 보낼 예정인 데이터는 쌓아두는데, 쌓인 양이 한계치를 넘어서면 그때 세그먼트로 만들어 보낸다. 이때 한계치는 최대 세그먼트 길이나 혼잡 제어 원도 중 작은것으로 한다.</p><p><img src="P1.jpg" alt="네이글 알고리즘"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본적으로 TCP에서는 네이글이 ON이 되어있음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> optval = TRUE;</span><br><span class="line"></span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서버에서 Nagle 알고리즘을 사용중이라도 클라이언트가 Nagle off 상태에서 Send 요청하면 바로바로 전송해준다.</span></span><br><span class="line"><span class="comment">// 서로 송수신이 활발하게 이루어지지 않은 상황에서 일방적으로 패킷을 전달할때 큰 효과가 생긴다.</span></span><br></pre></td></tr></table></figure><h3>TCP Disconnect 감지</h3><h4>유령세션</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">서버와 클라이언트가 둘다 ESTABLISTED 상태가 되었을때, 비정상적으로 끊겼을 경우, 무한히 대기하게 된다. 물리적인 원인으로 데이터 전송이 늦어진건지, 네트워크 연결에 문제가 있는건지 알수 없다. 이를 해결하기 위해서 Keepalive와 heartbeat를 쓰면된다.</span><br></pre></td></tr></table></figure><h4>KeepALive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">소켓에 자체적으로 HeartBeat 검사. 일정 시간을 설정한 다음 그 시간을 넘으면 검사 패킷을 보내고 일정 이상 응답이 오지 않으면 연결 종료</span><br></pre></td></tr></table></figure><h4>HeartBeat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">심장 박동 처럼 일정 주기로 서버와 클라이언트가 패킷을 주고 받으면서 서로 살아있는지 검사하는 방법.</span><br></pre></td></tr></table></figure><h3>소켓 옵션</h3><h4>SO_KEEPALIVE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">소켓 자체에서 연결 여부를 확인한다.</span><br><span class="line">하지만 TCP가 주기적으로 확인하는 시간이 너무 길어서 사용할 수준이 아니라고 판단된다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> optval = TRUE;</span><br><span class="line"></span><br><span class="line">setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br></pre></td></tr></table></figure><h4>SO_LINGER</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">소켓 송신 버퍼에 미전송 데이터가 있을때 CloseSocket() 함수의 리턴 지연 시간을 제어할수 있다.  LINGER 옵션은 TCP 소켓에만 사용할수 있다. UDP는 프로토콜 수준에서 정상 종료와 강제 종료 개념을 제공하지 않기 때문이다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LINGER optval;</span><br><span class="line">optval.l_onoff = <span class="number">1</span>;</span><br><span class="line">optval.l_linger = <span class="number">10</span>;</span><br><span class="line">setsockopt(sock, SOL_SOCKET, SO_LINGER, (<span class="keyword">char</span> *)&amp;optval, <span class="keyword">sizeof</span>(optval));</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Linger(l_onoff)</th><th style="text-align:center">Linger(l_linger)</th><th style="text-align:center">closesocket 함수 동작</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">사용안함</td><td style="text-align:center">기본동작</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">곧바로 리턴후, TCP 강제종료</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">양수</td><td style="text-align:center">송신버퍼 데이터 모두 전송후 정상 종료 (실패시 강제 종료와 버퍼삭제)</td></tr></tbody></table><h5>closesocket()</h5><ol><li>소켓을 닫고 할당한 소켓 자원을 반환한다. closesocket 함수 리턴 후에는 해당 소켓을 통신에 사용할수 없다.</li><li>TCP 수준에서 연결 종료 절차(4 Way HandShake <fin>)을 시작한다.</fin></li></ol><h5>shutdown()</h5><table><thead><tr><th style="text-align:center">옵션</th><th style="text-align:left">기능</th></tr></thead><tbody><tr><td style="text-align:center">SD_RECEIVE</td><td style="text-align:left">소켓에 대해 데이터 수신이 금지된다. (실제로는 Recv 함수 호출시 자동 에러 호출한다.)</td></tr><tr><td style="text-align:center">SD_SEND</td><td style="text-align:left">소켓에 대해 데이터 송신이 금지된다.</td></tr><tr><td style="text-align:center">SD_BOTH</td><td style="text-align:left">소켓에 대해 데이터 송수신이 금지된다.</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SD_SEND를 옵션을 사용할 경우, 상대편에 FIN 패킷을 보내면서 정상적 종료진행(<span class="number">4</span> Way HandShake)로 들어간다. 하지만 shutdown은 한쪽 방향 연결만 끊는다.(클라와 서버 Shutdown 함수가 필요하다.)</span><br><span class="line"></span><br><span class="line">shutdown 함수 호출후 closesocket 함수를 호출한다면, closesocket은 운영체제에 소켓자원만 반환하게 된다.</span><br><span class="line"></span><br><span class="line">shutdown(- , SD_BOTH) FIN을 보낸다.</span><br><span class="line">shutdown(- , SD_SEND) FIN을 보낸다.</span><br><span class="line">shutdown(- , SD_RECEIVE) 아무것도 안한다. Recv함수만 오류가 뜬다.</span><br></pre></td></tr></table></figure><h4>SO_SNDBUF, SO_REVBUF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">운영체제가 소켓에 할당하는 송신버퍼와 수신버퍼의 크기를 변경할수 있다. </span><br><span class="line">단, 송수신이 안되고 있을때 계속 Send, Recv 요청을 하게 될경우, Non-Paged Memory 문제로 터질수가 있다.</span><br></pre></td></tr></table></figure><h4>SO_SNDTIMEO, SO_RCVTIMEO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket() 함수로 만든 소켓은 블로킹 소켓이기 때문에, 데이터 전송 함수 호출 시 조건이 만족되지 않으면 무한정 블록된다.</span><br><span class="line">타임아웃 설정하는 함수. 밀리 초로 설정한다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> optval = <span class="number">3000</span>;  <span class="comment">// 3초</span></span><br><span class="line">retval = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, ...);</span><br></pre></td></tr></table></figure><h4>SO_REUSEADDR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">현재 사용중인 IP주소와 포트번호를 재사용한다.</span><br><span class="line"></span><br><span class="line">TCP와 UDP에서 사용이 가능하다.</span><br><span class="line"></span><br><span class="line">TCP 서버 종료 후 재실행시 bind함수에서 오류가 발생하는 일을 방지한다.</span><br><span class="line">(더미클라이언트에서 주로 문제가 발생하는데, TCP 상태가 TIME_WAIT에 머물러 있기 때문에, 이 상태에 의한 바인딩 에러가 생긴다.)</span><br><span class="line"></span><br><span class="line">여러 IP주소를 보유한 호스트에서 같은 기능의 서버를 IP주소별로 따로 운용할수 있다.</span><br><span class="line"></span><br><span class="line">멀티캐스팅 응용 프로그램이 같은 포트 번호를 사용할수 있게 한다.</span><br></pre></td></tr></table></figure><h3>TCP Connect(3 Way HandShake)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 </span><br><span class="line">먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.</span><br></pre></td></tr></table></figure><p><img src="P2.png" alt="3 Way HandShake"></p><h3>GraceFul Shutdown(4 Way HandShake)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">우아한 종료(데이터의 유실없이 안전히 연결 종료)</span><br></pre></td></tr></table></figure><p><img src="P3.PNG" alt="4 Way HandShake"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIME_WAIT은 먼저 종료를 시작한 쪽에서 생긴다.</span><br><span class="line">서버에서 Linger 옵션을 이용해서 Time_out 을 막으면 생기지 않는다.(어차피 서버에서 클라이언트로 보낼 데이터는 없기 때문에 사용함.)</span><br></pre></td></tr></table></figure><h2>I/O Event Notification Modelr</h2><h3>Synchronous</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">작업을 요청한 후 해당 작업의 결과가 나올때까지 기다린뒤 처리한다.</span><br></pre></td></tr></table></figure><h3>ASynchronous</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">작업을 요청해 놓은뒤, 해당 작업이 완료되면 그 때 완료되었음을 통지 받고 그때 따른 처리를 한다. </span><br><span class="line">IO작업에 대해 Completion을 기다린다. 운영체제 단계의 비동기 API 를 통해 이루어지며 IO 작업이 Completion 되면 그에 적합한 Hanlder를 이용해서 처리한다.</span><br></pre></td></tr></table></figure><h3>Blocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I/O 작업에서 Blocking으로 동작할 경우 해당 I/O가 끝날때 까지 대기해야된다.</span><br></pre></td></tr></table></figure><h3>NonBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">작업을 완료할수 있다면 완료하고 그렇지 않는다면 바로 리턴해 버린다.</span><br><span class="line">비동기와 논블록은 같지 않다.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ULONG isNonBlocking = <span class="number">1</span>;</span><br><span class="line">ioctlsocket(socket, FIONBIO, &amp;isNoBlocking)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">논블록킹 으로 처리할경우, 처리를 하더라도 실패할수 있는데 WSAWOULDBLOCK은 오류에 해당하지 않는다.</span><br></pre></td></tr></table></figure><h3>I/O Event 통지 모델이 필요한 이유</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이벤트 통지 모델을 이용하면 Thread 갯수를 훨씬 줄일수 있으며, 동시 접속자가 많을 수록 이벤트 통지 모델을 이용하는 편이 성능이 좋다.</span><br></pre></td></tr></table></figure><h2>SELECT 방식</h2><h3>POSIX 표준</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT는 이벤트 별로 감시할 소켓들 등록(FD_SET)하고, 등록된 소켓에 뭔가 이벤트가 발생했을 경우, 그걸 확인하는 방식으로 동작한다.</span><br></pre></td></tr></table></figure><h4>장단점</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">지원하는 OS가 많아 이식성이 좋다.(POSIX 표준)</span><br><span class="line"></span><br><span class="line">검사할수 있는 FD에 제한이 있다.</span><br><span class="line">매번 검사할때 마다 루프로 FD를 다 검사해야되서 속도가 느리다.</span><br></pre></td></tr></table></figure><h3>SELECT 모델의 이벤트 통지 방식</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Event Loop를 통해 매번 소켓의 상태를 확인한뒤 처리를 하기 때문에 동기 방식이다.</span><br><span class="line">TimeOut을 없이 만들어내면 이벤트가 발생할때까지 진행하지 않으므로, NonBlocking</span><br></pre></td></tr></table></figure><h2>Windows I/O 통지 모델</h2><h3>WSAASyncSelect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">특정 소켓에 통지 받을 이벤트와 통지 받을때 사용할 메세지를 지정해 주면 이벤트가 생길때 메세지 큐를 사용해 윈도우 메세지의 현태로 통지한다. </span><br><span class="line">소켓 이벤트를 윈도우 메세지 형태로 전달받을수 있으니, 다른 메세지 처리 하듯이 일관성 있게 처리가능하기 때문에 편리하다.</span><br><span class="line">윈도우 메시지 큐이기 때문에 프로시저와 HWND가 필요하다. 윈도우 메세지와 함께 처리하기 때문에 성능이 저하될수 있다. </span><br><span class="line">특정 IO 작업이 완료되면 운영체제가 그때 마다 메세지를 보내기 때문에 비동기방식이다.</span><br><span class="line">이 함수를 호출하면 해당 소켓은 자동으로 논블락으로 바뀐다. 따라 IO작업은 논블락이다.</span><br></pre></td></tr></table></figure><h3>Overlapped I/O CallBack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WSASend, WSARecv를 할때, Overlapped 구조체를 통해 IO를 중첩할수 있다.</span><br><span class="line">WSASend(RECV) 함수 인자 LPWSAOVERLAPPED, LPWSAOVERALPPED_COMPLETION_ROUTINE 인자가 중요인데,LPWSAOVERLAPPED는 IO 작업이 끝낫음을 통지하기 위해 이벤트를 등록하는 구조체이다.</span><br><span class="line">LPWSAOVERALPPED_COMPLETION_ROUTINE는 IO 작업이 끝났을때, 수행할 함수의 주소를 넘긴다. 그러면 IO작업이 끝난 다음 APC 큐에 들어가서 하나씩 완료 루틴 함수를 수행한다.</span><br></pre></td></tr></table></figure><h4>장단점</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">사용자가 지정한 버퍼로 바로 복사가 일어나기 때문에 데이터 복사 비용이 줄어든다.</span><br><span class="line">멀티 스레드에 특화된 방식이 아니다.</span><br><span class="line">운영체제가 내부적으로 IO작업을 한뒤 끝나면 그걸 알려준다. = 비동기</span><br><span class="line">IO작업이 끝나지 않아도 함수는 바로 리턴되고, 다음 명령어로 넘어가 다른 작업을 수행할수 있다. = 논블럭</span><br></pre></td></tr></table></figure><h1>WSA 소켓 에러 정리</h1><h2>WSA_WOULDBLOCK</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WOULDBLOCK은 Data 를 다 보내지 못했다는 의미</span><br><span class="line">넌블럭킹에서 나오는 에러메세지.</span><br><span class="line">소켓 동작이 원래 블로킹되었어야 하는데, 그렇지 않고 빠져나왔을때 나타난다.</span><br></pre></td></tr></table></figure><h2>WSA_IO_PENDING</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">비동기 입출력에서 나온다.</span><br><span class="line">정상적인 동작이다. </span><br><span class="line">비동기 입출력이 곧바로 완료되지 않으면, 이 에러를 뱉는다.</span><br></pre></td></tr></table></figure><h1>도메인(DNS Server)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">최상위 DNS 서버 IP는 고정</span><br><span class="line">하위에 다뤄질 DNS서버를 구축해야 된다.</span><br><span class="line">abc.com 이라는 홈페이지가 있을때, com이 관리하는 도메인서버에 서비스 요청이 들어가고 그 다음 그 서버에서 abc를 관리하는 도메인 서버에 가서 IP를 가져온다.</span><br><span class="line"></span><br><span class="line">새로운 DNS서버를 연결해서 하위 도메인을 다룰수 있고, DNS서버를 제공하는 업체들은 분산적으로 서비스를 제공한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">만약 abc.com를 내가 샀다면, DNS 서버를 내가 운영하고 있는게 있다면  *.abc.com은 내 마음대로 사용가능하다.</span><br><span class="line"></span><br><span class="line">DNS도 캐시로 처리하기 때문에 만약 서버 이전을 하면 빠르게 적용이 안된다.</span><br><span class="line">모든 DNS에는 TTL이 들어간다.(패킷에서의 TTL과 의미가 다르다. = 초단위, 패킷 = 라우터 처리 카운트)</span><br></pre></td></tr></table></figure><h2>DDNS (Dynamic DNS)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">엄청 잘 변하는 유동 IP를 DNS 한다.</span><br><span class="line">실시간으로 변동이 가능</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#game-server-programming-1&quot;&gt;Game Server Programming 1&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#osi-7%EA%B3%84%EC%B8%B5-tcpip-4-
      
    
    </summary>
    
    
      <category term="GameServer, Winsock, TCP/IP" scheme="https://Mutesk.github.io/tags/GameServer-Winsock-TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Operation System Content</title>
    <link href="https://Mutesk.github.io/2018/03/19/OperationSystem/"/>
    <id>https://Mutesk.github.io/2018/03/19/OperationSystem/</id>
    <published>2018-03-19T10:08:06.084Z</published>
    <updated>2018-03-19T10:54:31.699Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#operation-system-content">Operation System Content</a></li><li><a href="#thread--process">Thread / Process</a><ul><li><a href="#process">Process</a></li><li><a href="#thread">Thread</a></li></ul></li><li><a href="#pcb">PCB</a></li><li><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4%EB%8F%84">프로세스와 쓰레드 상태 전이도</a><ul><li><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4%EB%8F%84">프로세스 상태 전이도</a></li><li><a href="#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4%EB%8F%84">스레드의 상태 전이도</a></li></ul></li><li><a href="#logical-address-physical-address">Logical Address, Physical Address</a><ul><li><a href="#logical-address%EB%85%BC%EB%A6%AC%EC%A0%81-%EC%A3%BC%EC%86%8C">Logical Address(논리적 주소)</a></li><li><a href="#physical-address%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C">Physical Address(물리 주소)</a></li></ul></li><li><a href="#ipcinter-process-communication-mechanism">IPC(Inter-Process Communication) Mechanism</a><ul><li><a href="#%EB%B0%B0%EA%B2%BD">배경</a></li><li><a href="#%EB%AA%A9%EC%A0%81">목적</a></li><li><a href="#ipc-%EA%B8%B0%EB%B2%95%EC%9D%98-%EC%A2%85%EB%A5%98">IPC 기법의 종류</a></li></ul></li><li><a href="#interrupt">Interrupt</a><ul><li><a href="#%EC%A0%95%EC%9D%98">정의</a></li><li><a href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%A2%85%EB%A5%98">인터럽트 종류</a></li><li><a href="#isrinterrupt-service-routine">ISR(Interrupt Service Routine)</a></li><li><a href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EB%B0%9C%EC%83%9D%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">인터럽트 발생을 확인하는 방법</a></li></ul></li><li><a href="#top-half-bottom-half">Top Half, Bottom Half</a><ul><li><a href="#%EB%B0%B0%EA%B2%BD-1">배경</a></li><li><a href="#%EB%AA%A9%EC%A0%81-1">목적</a></li><li><a href="#top-half">Top Half</a></li><li><a href="#bottom-half">Bottom Half</a></li><li><a href="#%EA%B3%BC%EC%A0%95">과정</a></li></ul></li><li><a href="#hard-link-symbolic-link">Hard Link, Symbolic Link</a><ul><li><a href="#hard-link">Hard Link</a></li><li><a href="#symbolic-link">Symbolic Link</a></li><li><a href="#inode">iNode</a></li></ul></li><li><a href="#race-condition">Race Condition</a><ul><li><a href="#%EC%A0%95%EC%9D%98-1">정의</a></li><li><a href="#%EB%AC%B8%EC%A0%9C%EC%9D%98-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88">문제의 해결 방안</a></li><li><a href="#%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD">임계 영역</a></li></ul></li><li><a href="#deadlock">Deadlock</a><ul><li><a href="#%EC%A0%95%EC%9D%98-2">정의</a></li><li><a href="#deadlock%EC%9D%98-%EC%A1%B0%EA%B1%B4">DeadLock의 조건</a></li><li><a href="#deadlock%EC%9D%98-%ED%95%B4%EA%B2%B0%EC%98%88%EB%B0%A9">DeadLock의 해결(예방)</a></li></ul></li><li><a href="#context-switching">Context Switching</a><ul><li><a href="#%EC%A0%95%EC%9D%98-3">정의</a></li><li><a href="#context-switching-%EC%88%9C%EC%84%9C">Context Switching 순서</a></li><li><a href="#context-switching-of-process--thread">Context Switching of Process &amp; Thread</a></li></ul></li><li><a href="#preemptive--non-preemptive-scheduling">Preemptive / Non-Preemptive Scheduling</a><ul><li><a href="#preemptive%EC%84%A0%EC%A0%90-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81">Preemptive(선점) 스케쥴링</a></li><li><a href="#non-preemptive%EB%B9%84%EC%84%A0%EC%A0%90-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81">Non-Preemptive(비선점) 스케쥴링</a></li></ul></li><li><a href="#virtual-memory">Virtual Memory</a><ul><li><a href="#%EB%AA%A9%EC%A0%81-2">목적</a></li><li><a href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B8%B0%EB%B2%95">가상 메모리 기법</a></li><li><a href="#mmumemory-management-unit">MMU(Memory Management Unit)</a></li></ul></li><li><a href="#priority-queue">Priority Queue</a></li><li><a href="#difference-between-system-call-and-interrupt">Difference between System Call and Interrupt</a><ul><li><a href="#system-call">System Call</a></li><li><a href="#interrupt-1">Interrupt</a></li></ul></li><li><a href="#locality-of-reference%EC%B0%B8%EC%A1%B0%EC%9D%98-%EC%A7%80%EC%97%AD%EC%84%B1">Locality of Reference(참조의 지역성)</a><ul><li><a href="#%EC%A7%80%EC%97%AD%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC">지역성의 원리</a></li></ul></li><li><a href="#cache-memory">Cache Memory</a><ul><li><a href="#cache-miss">Cache Miss</a></li></ul></li><li><a href="#atomic-operation">Atomic Operation</a></li><li><a href="#paging-demand-paging-technique">Paging, Demand Paging Technique</a><ul><li><a href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95">페이징 기법</a></li><li><a href="#page-fault">Page Fault</a></li><li><a href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4page-replacement-%EC%A0%95%EC%B1%85">페이지 교체(Page Replacement) 정책</a></li><li><a href="#thrashing%EC%93%B0%EB%A0%88%EC%8B%B1">Thrashing(쓰레싱)</a></li></ul></li><li><a href="#segment-technique">Segment Technique</a><ul><li><a href="#%EC%A0%95%EC%9D%98-4">정의</a></li></ul></li><li><a href="#pipeline-processing-%EB%B0%A9%EC%8B%9D">Pipeline Processing 방식</a><ul><li><a href="#pipeline">Pipeline</a></li><li><a href="#pipeline-%EB%AA%A9%EC%A0%81">Pipeline 목적</a></li><li><a href="#%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%97%90%EC%84%9C-%EC%A4%91%EC%9A%94%ED%95%9C-%EC%A0%90">파이프라인에서 중요한 점</a></li></ul></li><li><a href="#%EC%A3%BC-%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98ramrom---cache-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1">주 기억 장치(RAM/ROM) &lt;-&gt; Cache 간 데이터 전송</a><ul><li><a href="#mapping-process">Mapping Process</a></li><li><a href="#cache-arragement">Cache Arragement</a></li></ul></li><li><a href="#risc-cisc">RISC, CISC</a><ul><li><a href="#riscreduced-instruction-set-computer">RISC(Reduced Instruction Set Computer)</a></li><li><a href="#cisccomplexed-instruction-set-computer">CISC(Complexed Instruction Set Computer)</a></li></ul></li><li><a href="#garbage-collection">Garbage Collection</a><ul><li><a href="#%EC%A0%95%EC%9D%98-5">정의</a></li><li><a href="#%EB%AA%A9%EC%A0%81-3">목적</a></li><li><a href="#gc-algorithm">GC Algorithm</a></li></ul></li><li><a href="#rpc-rmi">RPC, RMI</a><ul><li><a href="#rpcremote-procedure-call">RPC(Remote Procedure Call)</a></li><li><a href="#rmiremote-method-invocation">RMI(Remote Method Invocation)</a></li></ul></li></ul><!-- /TOC --><h1>Thread / Process</h1><h2>Process</h2><pre><code>    A Program in Execution(실행중인 프로그램)    하나의 프로세스는 적어도 하나의 스레드를 포함    Code, Data, File, Register, Stack, Thread를 포함하는 개념</code></pre><h2>Thread</h2><pre><code>    프로세스의 실행 단위(흐름)    Code, Data, File은 스레드 간 공유되는 자원이며, 프로세스에서 확보한 공간이다.    Register, Stack은 스레드 간 독립적인 자원이며, 프로세스에서 확보해놓은 메모리 공간 내에서 스레드마다 별도의 공간을 가진다.</code></pre><h1>PCB</h1><pre><code>Process Control Block 프로세스 제어 블록프로세스 생성 시 마다 고유의 PCB를 생성한다.프로세스에 대한 중요 정보를 저장하고, 불러오는 작업을 하기 위해 이용된다.프로세스 고유 식별자 포인터, 프로세스의 현재 상태, 스케쥴링 우선순위, CPU 레지스터 정보, 주기억장치 관리 정보 등을 포함하고 있다.(PID, Program Counter, File, Pointer, Register, etc ...)</code></pre><h1>프로세스와 쓰레드 상태 전이도</h1><h2>프로세스 상태 전이도</h2><ul><li><p>Running</p><p>​<br>Process가 CPU에 의해 수행되고 있는 상태.<br>TimeOut에 의해 Ready Queue로 이동될수 있음.<br>IO 등에 의해 Block 될수 있다.</p></li><li><p>Ready</p><pre><code>  프로세스가 실행중이지만, CPU에 의해 스케쥴링이 되지않아, 실질적으로 수행이 되지 않은 상태.   Dispatch되면 Running 상태로 전이된다.</code></pre></li><li><p>Block</p><pre><code>  Running 상태의 프로세스가 인터럽트 등에 의해 Block 되었을때의 상태.   Block이 끝나면 스케쥴링을 위해 Ready Queue로 이동한다.</code></pre></li></ul><h2>스레드의 상태 전이도</h2><ul><li><p>Runnable</p><pre><code>  스케쥴링 Timeout(), Notify(), I/O Finish 등 다시 실행시킬수 있게 된 상태</code></pre></li><li><p>Not Runnable</p><pre><code>  Suspend(), Wait(), Sleep() 등 I/O Block 등에 의해 실행 불가능하게 된 상태</code></pre></li><li><p>Dead</p><pre><code>  실행중인 쓰레드가 Stop 혹은 Exit되었을때.  실행 불가능한 스레드가 Stop 되었을때.</code></pre></li></ul><h1>Logical Address, Physical Address</h1><h2>Logical Address(논리적 주소)</h2><pre><code>호스트나 라우터가 사용하는 논리적 주소네트워크에서는 IP주소를 의미, 로컬에서는 CPU가 메모리에 접근하기 위해 사용하는 Virtual Address로 볼수 있다. ex) ARP(Address Resolution Protocal)</code></pre><h2>Physical Address(물리 주소)</h2><pre><code> 로컬 주소라고도 하며, 로컬 네트워크에서만 유효한 주소 일반적으로 하드웨어로 구현하며, 호스트나 라우터 내에 포함되어 있음. ex) TLB(Translation Lookaside Block)       - 가상 주소에서 물리주소의 변환의 속도를 위한 캐싱       - 최근에 참조한 주소 변환 정보를 캐싱해 주었다가 재사용</code></pre><h1>IPC(Inter-Process Communication) Mechanism</h1><h2>배경</h2><pre><code>프로세스 간에는 가상 메모리 공간을 공유하지 않는다. (기본적으로 프로세스 간 커뮤니케이션은 불가능)</code></pre><h2>목적</h2><pre><code>프로세스 간 통신을 위해서 존재</code></pre><h2>IPC 기법의 종류</h2><pre><code>+ 공유 메모리 : 메모리 자체를 공유+ File, Socket : 하나의 파일을 여러 프로세스가 공유하거나, Socket을 이용해서 메세지를 넘긴다.+ Signal : 한 프로세스가 다른 프로세스에게 Signal을 줄수 있다.+ Message Qeueing : 한 프로세스가 다른 프로세스에게 메세지 큐를 이용해 전달한다.+ Pipe : 파이프를 이용해 메시지를 주고 받을수 있다.+ Semaphore : 동기화 기법과 겸용해서 IPC에서 1:N 관계에서 사용한다.+ Message Passing : 병렬 컴퓨팅을 이용하기 위한 표준 규격+ Memory Mapping File : 가상 메모리처럼 프로세스 주소 공간을 예약하고, 예약한 영역에 물리 저장소를 커밋하는 기능을 제공한다.</code></pre><h1>Interrupt</h1><h1>Interrupt</h1><h2>정의</h2><pre><code>A Signal to the Processor or An Instruction in Software.CPU 외부의 HW or SW에 의해 정상적인 실행 흐름을 변경하여, 시급한 작업을 먼저 수행한뒤, 실행중인 프로세스로 복귀하는 방법</code></pre><ul><li>비동기적인 주변장치의 서비스 요청 이벤트 처리</li><li>인터럽트 발생 시 복귀 주소를 저장해 두었다가, ISR(Interrupt Service Routine) 마지막에 복귀 명령에 이용한다.</li><li>운영체제는 인터럽트 의존적이다.</li></ul><h2>인터럽트 종류</h2><pre><code>+ Hardware Interrupt(External) : 입출력 등 외부 장치에서 발생하는 인터럽트+ Software Interrupt(Internel과 유사) : 잘못된 명령이나 데이터 사용에 의해 발생하는 인터럽트 = Trap</code></pre><p><em>실질적으로 Hardware Interrupt만 존재한다. Trigger가 SW일 경우 Software Interrupt라고 부르기만 할뿐</em><br><em>실질적으로 Hardware Interrupt만 존재한다. Trigger가 SW일 경우 Software Interrupt라고 부르기만 할뿐</em></p><h2>ISR(Interrupt Service Routine)</h2><pre><code>인터럽트가 발생하면, 유저모드에서 커널 모드로 들어가서 인터럽트를 처리한다.</code></pre><ul><li>인터럽트가 발생하면 현재 프로그램 상태를 PCB에 저장</li><li>Interrupt Vector(인터럽트에 해당하는 ISR 실행 정보를 담는 벡터)를 탐색</li><li>인터럽트 처리 : 요청 장비를 식별, 실질적 인터럽트 처리</li><li>상태를 복구하고, PC에 저장된 프로그램 상태를 통해 실행 개재</li></ul><h2>인터럽트 발생을 확인하는 방법</h2><ul><li>Polling : 하나씩 인터럽트가 걸린 프로세스를 확인</li><li>Vector Interrupt System : 인터럽트 요청을 한 프로세스를 확인할수 있다.</li><li>Daisy-Chain : 하드웨어적 방법으로 확인한다.</li></ul><h1>Top Half, Bottom Half</h1><h2>배경</h2><pre><code>인터럽트가 발생했을 시, 데이터를 가져오고 수행하는 단계에서 처리 과정의 시간이 길어질 경우 오랫동안 아무 작업을 못한다는 단점이 있다.</code></pre><h2>목적</h2><pre><code>인터럽트가 발생했을 때 데이터를 가져오는 빠른 동작을 수행하고, 데이터를 처리하는 동작은 그 이후에 수행한다.</code></pre><h2>Top Half</h2><pre><code>데이터를 가져오는 동작 -&gt; 비교적 빠른 동작</code></pre><h2>Bottom Half</h2><pre><code> 가져온 데이터를 처리하는 동작 -&gt; 비교적 느린 동작</code></pre><h2>과정</h2><pre><code>인터럽트 Disable --&gt; Top-Half 처리 --&gt; 인터럽트 Enable --&gt; Bottom-half 처리</code></pre><h1>Hard Link, Symbolic Link</h1><h2>Hard Link</h2><pre><code>Original File Data를 가르키는 INode를 직접 가르키고 있다.(원본과 동일한 inode)Hard Link된 파일을 수정하면 원본도 같이 수정된다.</code></pre><h2>Symbolic Link</h2><pre><code>원본 파일 자체에 Link를 연결한 방식바로가기와 유사한 개념, 심볼릭 링크 파일을 수정해도 원본은 변하지 않는다.</code></pre><h2>iNode</h2><pre><code>커널 내에 현재 사용중인 파일의 대한 자료구조해당 파일의 대한 대부분의 정보를 가진다. : 파일의 소유권/권한, 디스크 내의 물리적 주소, 파일의 링크 수/형태/크기, 파일 관련 시간, inode 수정 시간사람은 파일을 이름으로 구분하고 , 컴퓨터는 iNumber로 구분한다.</code></pre><h1>Race Condition</h1><h2>정의</h2><pre><code>스레드 간 데이터를 공유하면서 발생하는 논리적 오류</code></pre><h2>문제의 해결 방안</h2><pre><code>데이터에 접근하는 연산을 Atomic Operation으로 처리한다.Critical Section으로 설정함으로써 동기화 한다.</code></pre><h2>임계 영역</h2><ol><li><p>스레드들이 하나의 자원에 접근할 때 순서를 만들어 실행해 준다.</p></li><li><p>공유 자원의 독립적인 처리를 보장한다.</p></li><li><p>임계 구역의 관리 방법(Lock)과 동기화 객체</p><pre><code> - Mutex(Mutual Exclusion 상호배제) : 제어되는 섹션에 하나의 스레드만을 허용 - Semaphore : 공유 리소스에 접근할수 있는 최대 허용치만큼 동시에 접근할수 있도록 허용 (열쇠가 여러개 있음.) - Event : 쓰레드의 작업 순서나 시기를 결정한다.</code></pre></li></ol><h1>Deadlock</h1><h2>정의</h2><pre><code>프로세스가 자원을 얻지 못해 다음 처리를 못하는 상황= 원하는 리소스가 다른 프로세스(스레드)에게 할당되어 있기 때문에, 무한히 기다리게 되는 상황</code></pre><h2>DeadLock의 조건</h2><ol><li>Mutual Exclusion : 한 리소스는 두개의 프로세스에게 동시에 할당될수 없다.</li><li>Hold And Wait    : 한 프로세스가 한 리소스를 가지고 있고 필요한 또다른 리소스는 다른 프로세스가 가지고 있다.</li><li>No Preemption    : 할당되어 있는 리소스는 프로세스가 해제하기 전까지 강탈할수 없다.</li><li>Circular Wait    : P0가 원하는 자원은 P1이 P1이 원하는 자원은 P2가 … Pn이 원하는 자료는 P0가 가지고 있다.</li></ol><h2>DeadLock의 해결(예방)</h2><ol><li>Mutual Exclusion 부정  : 자원의 공유가 가능하다면 여러개의 프로세스가 동시에 점유할수 있다.</li><li>Hold And Wait 부정     : 미리 자원을 점유하지 못하고, 필요한 자원이 모두 이용 가능할 경우 한꺼번에 점유하고 실행된다.</li><li>No Preemption 부정     : 중간에 강제로 자원을 선점할수 있다.</li><li>Circular Wait 부정     : 각 프로세스에 우선순위를 부여하고 프로세스의 실행 순서를 지정한다.</li></ol><h1>Context Switching</h1><h2>정의</h2><pre><code>Running 상태에서 Task(스레드, 프로세스)가 사용하던 Context를 메모리 특정 영역에 저장한 후, 새로 수행될 Task의 Context를 PCB 또는 Stack에서 CPU 레지스터 영역으로 복사하여 수행되도록 하는 작업</code></pre><h2>Context Switching 순서</h2><ol><li>인터럽트 : 현재 상태를 PCB에 저장한다.</li><li>프로세스(스레드) 스케쥴링 : 프로세스(스레드) 스케쥴러에 의해 다음 프로세스를 Ready Queue에서 선택한다.</li><li>Dispatch : 다음 프로세스를 PCB에서 복구한다.</li></ol><h2>Context Switching of Process &amp; Thread</h2><ol><li>Process : 커널 레벨 문맥 교환</li><li>Thread  : 유저 레벨/ 커널 레벨 문맥 교환<ul><li>PCB가 저장되고 복귀하는 과정이 없기 때문에, 프로세스의 문맥교환보다 오버헤드가 줄고, 효율성이 올라간다.</li><li>하지만 동기화가 불완전하거나 불확실한 경우 Race Condition 발생 가능</li></ul></li></ol><h1>Preemptive / Non-Preemptive Scheduling</h1><h2>Preemptive(선점) 스케쥴링</h2><pre><code>우선순위가 높은 다른 프로세스가 실행중인 CPU를 강제로 빼앗아 사용할수 있음.</code></pre><h2>Non-Preemptive(비선점) 스케쥴링</h2><pre><code>CPU가 한 프로세스를 할당하면, 다른 프로세스는 CPU를 선점할수 없음.</code></pre><h1>Virtual Memory</h1><h2>목적</h2><pre><code>쉬운 프로그래밍이 가능하다 -&gt; 실제 물리주소와 물리적 구조를 몰라도 프로그래밍이 가능Multi-Programming의 정도를 올릴수 있다.메모리와 하드디스크 간 Swapping 횟수를 줄일수 있다.</code></pre><h2>가상 메모리 기법</h2><ol><li>CPU가 가상 메모리에 우선적으로 수행할 작업을 로드</li><li>Virtual Memory 공간에는 연속적인 가상 메모리가 구성된다.</li><li>MMU를 통해 가상 메모리의 논리적 주소를 물리적 주소로 사상(Mapping) 한다.<br>- 이 과정에서 MMU는 페이지 테이블을 거친다.</li><li>실제 메모리의 물리적 주소 공간에 페이지가 로드된다.</li></ol><h2>MMU(Memory Management Unit)</h2><pre><code>CPU가 메모리에 접근하는 것을 관리하는 장치.가상 메모리 주소와 실제 메모리 주소 사이의 변환을 위해 MMU는 변환 참조 버퍼(Translation Lookaside Buffer, TLB)라는 고속의 보조기억장치를 참조한다</code></pre><h1>Priority Queue</h1><h1>Priority Queue</h1><pre><code>우선순위 속성을 갖는 데이터를 다루며, 우선순위가 높을수록 앞에 자동정렬되어 배치된다.우선순위 큐는 힙(Heap, 완전 이진트리)를 이용해 구현된다.</code></pre><h1>Difference between System Call and Interrupt</h1><h2>System Call</h2><pre><code>유저 레벨에서 커널이 제공하는 서비스(OS 제공 하는 기능/모듈)를 이용하기 위해 호출된다.커널 영역에서 서비스를 이용하기 위한 인터페이스적 개념Application(User) &lt;-&gt; System Call &lt;-&gt; OS</code></pre><h2>Interrupt</h2><pre><code>주변 장치와 커널이 Communication하는 방식 중 하나(신호의 개념)주변 장치나 CPU가 자신에게 발생한 사건을 커널에게 알리기 위한 매커니즘</code></pre><h1>Locality of Reference(참조의 지역성)</h1><h2>지역성의 원리</h2><pre><code>주어진 시간동안 CPU가 메모리 참조가 제한된 영역에서만 이루어지는 현상지역성의 원리에 의해 한번 참조된 부분은 다시 참조될 확률이 높다.</code></pre><h1>Cache Memory</h1><pre><code>CPU의 빠른 처리 속도와 Main Memory의 느린 처리 속도 차이를 해결하기 위한 기법캐시 메모리는 지역성의 원리를 이용한 좋은 예제Cache &lt;-&gt; CPU  WORD 단위Cache &lt;-&gt; Main Memory  Block 단위</code></pre><h2>Cache Miss</h2><ol><li><p>Compulsory Miss</p><p>최초 데이터 접근 시 반드시 발생하는 미스</p></li><li><p>Capacity Miss</p><p>캐시 사이즈가 작아서 발생하는 미스, 캐시가 모든 블럭을 포함하지 않음.</p></li><li><p>Conflict Miss</p><p>캐시의 한 블락에 너무 많은 메모리 블럭이 매핑되어서 생기는 미스<br>(Set Associative / Direct Mapped)</p></li><li><p>Invalidation</p><p>두 CPU가 동시에 하나의 데이터에 접근하면서 발생하는 미스</p></li></ol><h1>Atomic Operation</h1><pre><code>Operation을 결합하여 하나의 Operation으로 표시되어, 결과가 성공이나 실패로 나타나는 Operation.Race Condition을 막기 위해 만들어졌다.연산이 끝날때 까지 다른 프로세스는 값의 변화에 대해 알수 없음.연산 실패시 시스템은 다른 Operation이 시작되기 전까지 이전의 실패한 상태를 저장.ex) InterlockedAdd, InterlockedExchange 등</code></pre><h1>Paging, Demand Paging Technique</h1><h2>페이징 기법</h2><pre><code>작업을 동일한 크기의 여러 페이지로 나누어 보조 기억장치에 저장해 두고, 작업이 실행을 시작하면, 필요한 때마다 해당 페이지를 주기억 장치로 로드하는 방식</code></pre><h2>Page Fault</h2><pre><code>해당 페이지(작업이 요구된 페이지)의 페이지 엔트리가 유효하지 않을때 발생</code></pre><h2>페이지 교체(Page Replacement) 정책</h2><ol><li><p>FIFO</p><ul><li>메모리에 오래 있던 페이지를 교환</li><li>계속 사용하는 페이지의 경우 문제가 발생할수 있다.</li><li>Belady’s Anomaly(벨라디의 모순)이 나타남 : 프로세스에게 프레임을 더 주었는데, 더 많은 페이지 폴트가 발생하는 현</li></ul></li><li><p>LRU(Least Recently Used)</p><ul><li>가장 오랫동안 사용하지 않은 페이지를 교체(지역성의 이론 근거하여 만들어짐)</li></ul></li><li><p>OPT<br>Optimal하게 페이지를 교체 구현이 어렵다.</p></li><li><p>LFU(Least Frequently Used)</p><ul><li>각 페이지들에 대해 참조된 횟수를 기준으로 교체</li></ul></li></ol><h2>Thrashing(쓰레싱)</h2><pre><code>메모리나 캐쉬 등에서 너무 많은 페이지 교체가 발생하는 현상 -&gt; 속도저하를 일으켜 성능을 떨어트린다.</code></pre><h1>Segment Technique</h1><h2>정의</h2><pre><code>각 작업을 여러개의 서로 다른 세그먼트로 나누어 작업 실행에 필요한 세그먼트만 주 기억장치로 적재하여 실행하는 방식세그먼트 기법에서는 주 기억장치가 작업을 동적인 크기로 할당한다. &lt;-&gt; 페이징에서는 동일한 Page크기로 분할</code></pre><h1>Pipeline Processing 방식</h1><h2>Pipeline</h2><pre><code>하나의 프로세스를 서로 다른 기능을 가진 여러 세부 서브 프로세스로 나누어 각 서브 프로세스가 동시에 서로 다른 데이터를 취급하도록 하는 방식</code></pre><h2>Pipeline 목적</h2><ol><li>프로세스 처리의 병렬성 증대<ul><li>병렬 시스템에서 각 프로세스 상에서 서로 다른 연산들이 동시에 수행된다.(파이프라인)</li></ul></li><li>MIMD(Multi Instruction Stream, Multi Data Stream)<ul><li>멀티 프로세서, 파이프라인 프로세서</li></ul></li></ol><h2>파이프라인에서 중요한 점</h2><pre><code>한 단계의 처리 시간이 다른 단계의 처리 시간과 큰 차이가 날 경우, 병목현상으로 인한 성능저하. 단계별로 상호 동기화가 필요</code></pre><h1>주 기억 장치(RAM/ROM) &lt;-&gt; Cache 간 데이터 전송</h1><h2>Mapping Process</h2><ol><li>Directed Mapping</li><li>Associative Mapping  : 무작정 빈곳을 찾아서 Cahce에 넣는 방식</li><li>(N-Way) Set Associative Mapping : Directed Mapping 방식을 사용하는 Cache N개로 구성. 저장된 데이터에 대해서는 Associative Mapping.</li></ol><h2>Cache Arragement</h2><ol><li>Cache 블록을 늘리는 방법<br>Spatial Locality(공간적 지역성)에 대한 고려가 필요</li><li>Cache Way 수를 늘리는 방법(Set-Associative)<br>Temporal Locality(시간적 지역성)에 대한 고려가 필요</li></ol><h1>RISC, CISC</h1><h2>RISC(Reduced Instruction Set Computer)</h2><pre><code>CPU 명령어 갯수를 줄여 하드웨어 구조를 간단하게 만드는 방법적은 수의 명령어만으로 명령어 집합을 구성고정 길이 명령어를 사용하여 빠른 해석이 가능파이프라인을 사용하지않음으로 많은 레지스터의 사용, 레지스터간 Save, Load 수행한다.</code></pre><h2>CISC(Complexed Instruction Set Computer)</h2><pre><code>복잡한 명령어 집합을 가짐.가변 길이 명령어를 사용한다.회로도가 많이 복잡하며, 레지스터 간 / 레지스터 - 메모리 / 메모리 - 메모리 연산을 수행한다.</code></pre><h1>Garbage Collection</h1><h2>정의</h2><pre><code>개발자가 명시적으로 해야 했던 메모리 관리를 자동적으로 처리하는 기법</code></pre><h2>목적</h2><pre><code>참조를 잃는 순간 지우는 등의 작업을 통해 메모리 누수를 방지한다.</code></pre><h2>GC Algorithm</h2><pre><code>Generation에 따라 적절한 알고리즘을 적용(Young-Tenured_Perm. 생성된지 얼마 안된 객체는 GC의 대상이 되기 쉽다.)</code></pre><ol><li><p>Serial</p><ul><li>하나의 Garbage Collector가 차례대로 다 처리하는 방식</li></ul></li><li><p>Parallel</p><ul><li>여러개의 Garbage Collector가 나눠서 처리하는 방식</li></ul></li><li><p>Stop the World</p><ul><li>프로세스가 일시적으로 실행을 멈추고, GC 수행하는 방식</li></ul></li><li><p>Concurrent</p><ul><li>프로세스 실행과 함께 GC를 진행</li></ul></li><li><p>Compacting / Non-Compacting</p><ul><li>단편화를 신경써서 압축을 하는 방식 / 하지않은 방식</li></ul><p>5-1. 단편화</p><pre><code> 내부 단편화 : 100 크기의 공간에 70크기의 프로세스가 들어가면 30의 공간이 남는데 이를 내부 단편화라고 한다. 외부 단편화 : 프로세스의 크기(120)가 남아 있는 메모리 공간(100)보다 크기 때문에 발생하는 단편화를 외부 단편화라고 한다.</code></pre></li><li><p>Copying</p><ul><li>특정 영역으로 복하하여 추후에 메모리를 해제하는 방식</li></ul></li></ol><h1>RPC, RMI</h1><h2>RPC(Remote Procedure Call)</h2><pre><code>다른 네트워크의 컴퓨터에 있는 함수를 호출할 수 있도록 해주는 저 수준의 프로세스 간 통신 방법- 네트워프 프로그래밍을 함수 호출 레벨 수준으로 작성할수 있게 해주는 API</code></pre><h2>RMI(Remote Method Invocation)</h2><pre><code>원격 메소드 호출로 네트워크 상에서 떨어져 있는 객체의 메서드를 투명(Transparent) 하게 호출해주는 방법- RPC와 비슷하지만 객체지향적 개념이 추가되었다고 볼수 있음.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#operation-system-content&quot;&gt;Operation System Content&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#thread--process&quot;&gt;Thread / Process&lt;
      
    
    </summary>
    
    
      <category term="CS, OS" scheme="https://Mutesk.github.io/tags/CS-OS/"/>
    
  </entry>
  
  <entry>
    <title>Programming Language(C/C++)</title>
    <link href="https://Mutesk.github.io/2018/03/19/Programming%20Language/"/>
    <id>https://Mutesk.github.io/2018/03/19/Programming Language/</id>
    <published>2018-03-19T10:03:31.111Z</published>
    <updated>2018-03-19T10:54:46.471Z</updated>
    
    <content type="html"><![CDATA[<hr><p>[TOC]</p><p><em>이 글은 C와 C++을 한권이라도 읽은 사람 대상으로 적었습니다. 개인 정리용에 가까우므로, 이걸로 공부하지마세요. !</em></p><h2>메모리 구조</h2><table><thead><tr><th style="text-align:center">CODE</th><th style="text-align:center">함수, 제어문, 상수 영역(컴파일시 결정)</th></tr></thead><tbody><tr><td style="text-align:center"><strong>DATA</strong></td><td style="text-align:center"><strong>전역 변수(컴파일시 결정)</strong></td></tr><tr><td style="text-align:center"><strong>BSS</strong></td><td style="text-align:center"><strong>초기화값이 없는 전역변수(컴파일시 결정)</strong></td></tr><tr><td style="text-align:center"><strong>HEAP</strong></td><td style="text-align:center"><strong>동적 할당(런타임)</strong></td></tr><tr><td style="text-align:center"><strong>Stack</strong></td><td style="text-align:center"><strong>지역 변수(런타임)</strong></td></tr></tbody></table><ul><li>스택에서 자료(로컬변수)를 만지는게 제일 빠르다.</li><li>가능한 전역변수는 사용하지않는게 속도상에서 좋다.</li><li>동적할당은 어느정도되면 안만들어진다. 32비트 컴퓨터일경우 (1.98G)</li></ul><h2>전처리기</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__DATA__ <span class="comment">// 컴파일 날짜를 나타내는 문자열 </span></span><br><span class="line">__TIME__ <span class="comment">// 현재 시간 문자열</span></span><br><span class="line">__FILE__ <span class="comment">// 파일 이름 포함 문자열</span></span><br><span class="line">__LINE__ <span class="comment">// 지금 현재 라인수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건부 컴파일</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> X</span></span><br><span class="line">    <span class="comment">// - #define이 되어있다면 처리한다.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 안되어있다면 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> #<span class="meta-keyword">if</span>문 종료</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> X</span></span><br><span class="line">     <span class="comment">// #define X이 안되어있다면 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//#elif   = else if</span></span></span><br><span class="line">    <span class="comment">// 되어 있다면</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">assert(<span class="comment">/* bool statement */</span>) <span class="comment">// 수식의 값이 기대하고 있는 값인가 확인할때 사용 -&gt; 실패하면 메세지 출력후 중단해버림.</span></span><br></pre></td></tr></table></figure><h2>함수 호출 스택</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug 중 일때, BreakPoint를 통해 인터럽트를 걸어주면(멈추게 하면), 함수 스택이 있다.</span><br><span class="line">영어로는 Call Stack이라고 하고, 사용하는 이유는, 현재 실행중인 서브루틴(함수)를 실행하고 어디로 돌아가야할지 절차들을 따르기 위함이다. ( Recursive : 재귀 연산할때 잘못하면 Stack Overflow가 뜨는 이유)</span><br><span class="line"></span><br><span class="line">&lt;Tip 1&gt;</span><br><span class="line">static 변수는 가능한 쓰지 않은게 좋은데, 이 변수는 다른 소스파일에서 extern으로 가져오려고 해도 메모리가 따로 할당받아진다. (cpp에서 선언한 변수 다른 cpp에서 사용하고싶을때의 상황)</span><br></pre></td></tr></table></figure><h2>바이트 순서</h2><ul><li><p>빅 엔디안은 큰 단위의 바이트가 앞에 오는 방식, 리틀엔디안은 작은 단위의 바이트가 뒤에 오는 방식이다.</p></li><li><p>네트워크 장비들은 빅 엔디안을 쓰고, 우리와 같은 PC는 리틀 엔디안 식으로 저장한다.</p><p>![](PC의 리틀엔디안 저장.png)</p></li></ul><h2>Pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 접근 자료 크기 */</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">short</span> *p3 = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">p1++; <span class="comment">// p1 = 0x1004  // 접근하는 크기만큼 더해진다. sizeof(자료형 *)</span></span><br><span class="line">p2++; <span class="comment">// p2 = 0x1001</span></span><br><span class="line">p3++; <span class="comment">// p3 = 0x1002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 32bit에서는 Pointer의 크기는 4 Bytes, 64bit에서는 8 Bytes이며, 접근하는 크기는 각 자료형에 따라 다르다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 리틀 엔디안의 포인터 */</span></span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">10</span>]; <span class="comment">// 0x11 0x22 0x33 0x44 ... 가 들어있을때..</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)buffer;</span><br><span class="line"><span class="keyword">int</span> a = *p;<span class="comment">//를 할경우 0x44332211으로 저장된다.(리틀 엔디안)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0xffffff00</span>; </span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">char</span> x = *p; <span class="comment">// 딱 1만 가져온다. 1바이트 크기만큼 x는 0x00만 가지고 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">short</span> x = *p; <span class="comment">// 이 경우 x 는 0xff00을 가지고있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 배열 인덱싱 */</span></span><br><span class="line">*(p + <span class="number">1</span>) = p[<span class="number">1</span>]; <span class="comment">// 포인터 p에서 포인터의 크기만큼 1 * (32일때 4, 64일때 8) 씩 이동한다.</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = *(*(a + <span class="number">1</span>) + <span class="number">2</span>) <span class="comment">// 2차원 배열 같은 경우 한칸 아래 옆 2칸이므로,</span></span><br><span class="line">    <span class="comment">// a + (1 * 최대 열수 * 32일때 4, 64일때 8) + (2 * (32일때 4, 64일때 8)) 씩 움직인다.</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* void형 포인터 */</span></span><br><span class="line"><span class="comment">// 아무거나 가르킬 용도로 쓴다. 캐스팅 전용 포인터. 대부분 책에서 추천하지않은 이유가 이 포인터의 자료형을 모를때 무슨일이 일어날지 모른다. 오버해서 캐스팅하면 Corruption이 일어난다. (다른 자료에 까지 Write 할수도 있음.)</span></span><br></pre></td></tr></table></figure><h2>Const Pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C/C++ 사용하면서 조낸 헤깔린다</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 일때 const가 맨 앞에 있으면 화살표를 뒤로 그려서 num을 가르켜서 num을 상수화한다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr1 = &amp;val1; <span class="comment">// 일때 const가 맨앞이니 역시나 화살표 그리면 ptr1을 가르킨다. ptr1은 int *형이기 때문에 ptr1을 통해 val1은 수정하지못한다. ptr1은 수정가능!</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;val1; <span class="comment">// 이경우 const는 중간에 있으니 뒤로 화살표 그리면 ptr1을 가르키고, 그 뜻은 ptr1은 수정 불가능이 된다. 단 val1은 수정가능!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;val1; <span class="comment">// 앞에 있는 const는 val1을 상수화, 중간에 있는 const는 ptr1을 상수화한다. 둘다 수정 불가능!</span></span><br></pre></td></tr></table></figure><h2>Function Pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 콜백함수처럼 사용하는 방법 중 하나인 함수포인터이다.</span></span><br><span class="line"><span class="comment">// 함수도 메모리를 가진다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">void Test(void (*ptr) (void))</span><br><span class="line">&#123;</span><br><span class="line">    ptr();  <span class="comment">// Draw의 시작주소를 통해 호출!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*ptr1) (<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> c); <span class="comment">// 함수 포인터 변수 선언</span></span><br><span class="line">    ptr1 = function; <span class="comment">// 함수 포인터에 함수 시작주소 넣음.</span></span><br><span class="line">    </span><br><span class="line">    ptr1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// function(1,2,3) 이 호출된다.</span></span><br><span class="line">    Test(Draw);  <span class="comment">// Draw 전역 함수를 매개변수로 넘긴다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>구조체</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 규약이 발전하면서 구조체랑 클래스랑 다른건 접근지정자 말곤 없는것 같다.</span></span><br><span class="line"><span class="comment">// 클래스는 기본 private, 구조체는 public 이다.</span></span><br><span class="line"><span class="comment">// 구조체 바이트 정렬이 중요하다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 이렇게 있을때, Test는 1 + 4 = 5 바이트를 가지고 있지않다.</span></span><br><span class="line"><span class="comment">// 컴파일러가 구조체 정렬할때 가장 큰 자료형 기준으로 정렬한다.</span></span><br><span class="line"><span class="comment">// int가 제일 크므로 int + int = 8바이트</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)  <span class="comment">// 정렬 크기를 1바이트</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="comment">// 이 경우 5바이트가 나온다. 정렬 기법은 대부분 사용하지않지만, _aligned_malloc 같은 물리적으로 연속할당이 필수적인 상황이 있는데, 그 경우에 사용해야된다.&lt;거의 잘안씀.&gt;</span></span><br></pre></td></tr></table></figure><h2>인라인</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C에서의 매크로함수의 단점을 달피하고자 나왔다.</span><br><span class="line">함수 선언 앞에 inline을 쓰면된다. 그리고 헤더에 넣어야 한다.</span><br><span class="line">컴파일러가 최적화 해주는데 visual studio에서 컴파일러 최적화 옵션을 켜야만 동작한다. 껏다면 일반 함수.</span><br><span class="line">프로그래머가 인라인화 하더라도 컴파일러가 거부하면 일반함수로 된다.</span><br></pre></td></tr></table></figure><h2>정보은닉, 캡슐화</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">대부분 책에서는 정보은닉 및 캡슐화 예제를 적어놓고</span><br><span class="line"></span><br><span class="line">GetX, SetX 같은 함수를 만드는데 이럴경우 의미가 없어진다.</span><br><span class="line">Move함수를 만들어서 내부 변수만 움직이게 해주는게 좋다.</span><br><span class="line"></span><br><span class="line">&lt;Tip 2&gt;</span><br><span class="line">class 안에 맴버함수로 const를 넣게 되면, class 의 내부 변수를 만질수 없다.</span><br><span class="line">const 함수 안에서는 일반 함수또한 호출할수 없다. (const 끼리 호출가능하다.)</span><br></pre></td></tr></table></figure><h2>생성자, 소멸자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자</span></span><br><span class="line"><span class="comment">//Object Instance가 Alloc 될때 호출된다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BB(<span class="keyword">int</span> X)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">BB <span class="title">Data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 위 코드를 어셈블로 보자면, </span></span><br><span class="line"><span class="comment">// push 0</span></span><br><span class="line"><span class="comment">// lea ecx, [Data]</span></span><br><span class="line"><span class="comment">// 클래스 객체 대해서의 데이터 확보는 함수 호출시에 확보 되지만, 생성자는 바로 호출되지 않는다.</span></span><br><span class="line"><span class="comment">// 호출되는 순간은, 해당라인이 지나갈때 호출된다.</span></span><br><span class="line"><span class="comment">// 가능하면 if ~ else 로 두개의 객체를 선언하면 좋지않음.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 파괴자</span></span><br><span class="line"><span class="comment">// 함수를 빠져나오거나, delete가 선언되었을때 호출된다.</span></span><br><span class="line"><span class="comment">// 맴버함수로써 사용가능(생성자는 불가능) -&gt; 임의 호출은 좋지않다.</span></span><br></pre></td></tr></table></figure><h2>Placement New</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc으로 생성한 객체를 생성자따로 호출할 방법이 바로 Placement New이다. */</span></span><br><span class="line">BB *px = (BB *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BB));</span><br><span class="line">BB *p3 = <span class="keyword">new</span> (px) BB; <span class="comment">// Placement New - 참고로 px와 p3은 같다. new해서 받은 리턴값을 굳이 안받아도 된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 단 이럴경우 delete로 호출할수 없으며</span></span><br><span class="line"><span class="built_in">free</span>(px); <span class="comment">// 이럴경우도 문제가 생긴다.</span></span><br><span class="line"></span><br><span class="line">px-&gt;~BB(); <span class="comment">// 소멸자를 호출해서 파괴시켜야된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 재미난 캐스팅 -&gt; 잘 안쓰지만 C++가 시발 존나 어려운 이유 중 하나</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10000</span>];</span><br><span class="line">BB *px = <span class="keyword">new</span> (A) BB; <span class="comment">// int 배열 A를 메모리 공간으로 쓴다.</span></span><br><span class="line">px-&gt;~BB(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Array[<span class="number">100</span>];</span><br><span class="line">CPlayer *p = (CPlayer *)Array; <span class="comment">// Placement New가 없고, 이 경우 이상한값이 나올수있음.</span></span><br><span class="line">p-&gt;Print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//동적할당을 받거나 캐스팅을 한 객체에 대해서 생성자호출을</span></span><br><span class="line"><span class="comment">//하고싶을때 Placement New를 해줘야 한다.</span></span><br><span class="line"><span class="comment">//물론 이건 상속 및 가상함수가 안에 포함되어 있다면 바로 뻑난다.</span></span><br></pre></td></tr></table></figure><h2>맴버 이니셜라이저</h2><p><em>const 맴버 변수를 사용한다면 필수 사용! has-a 상속관계에서도 사용!</em></p><p><em>class 맴버 변수에 대해 자체적으로 사용해야된다면 포인터 변수를 따로 빼서 사용하면 훨씬 빠르다.</em></p><p><em>this 포인터는 너무 느림.!</em></p><h2>복사 생성자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 대입연산은 얇게 복사해버린다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line">C A;</span><br><span class="line">C B = A; <span class="comment">// 가있을때</span></span><br><span class="line"><span class="comment">// 완전 똑같이 복사해버려서 얇게 복사!</span></span><br><span class="line"><span class="comment">// A가 소멸자 호출을 해버리면 B는 쓰레기값이 되어버린다. -&gt; 또는 에러 핸들러로 꺼져버린다.</span></span><br><span class="line"><span class="comment">// 두번째로는 둘이 가르키는게 다 같아버려서 A가 변경되면 같이 변경된다. (포인터값이 있을때)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이때 복사생성자를 통해 깊게 복사시켜준다.</span></span><br><span class="line">C(C&amp; CopyC)</span><br><span class="line">&#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Friend, Const, Static</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 이것도 오지게 짜증난다. */</span></span><br><span class="line"><span class="comment">// const 객체는 무조건 const 맴버 함수끼리만 가능 - 복습</span></span><br><span class="line"><span class="comment">// non-const,  const 함수는 오버로딩이 가능함.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Friend</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span>;</span> <span class="comment">// Girl에서 Boy 클래스를 맘대로 건들일수 있음.  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Boy Boy; <span class="comment">// 이 객체를 통해 맘대로 건든다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Point <span class="title">PointAdd</span><span class="params">()</span></span>; <span class="comment">// 외부에서 사용가능하게 하는 메소드이다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">PointAdd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 여기로 구현가능!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static</span></span><br><span class="line"><span class="comment">// 전역변수에 선언된 Static의 의미</span></span><br><span class="line"><span class="comment">// = 선언된 파일 내에서는 참조를 허용!</span></span><br><span class="line"><span class="comment">// 함수 내에 선언된 Static</span></span><br><span class="line"><span class="comment">// = 한번만 초기화 되고, 지역변수와 달리 변수가 살아 있다.</span></span><br><span class="line"><span class="comment">// 맴버 함수나 맴버 변수에 static</span></span><br><span class="line"><span class="comment">// = 맴버변수 -&gt; 전역변수</span></span><br><span class="line"><span class="comment">// = 맴버함수 -&gt; static 변수만 가능</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">// Static Member Variable</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">// 주로 스레드 함수로 사용가능하며 this 포인터 사용불가능하다.</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(x); <span class="comment">// 오직 애만 가능!</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CTest::X; <span class="comment">// 한번 선언을 해줘야 한다.</span></span><br></pre></td></tr></table></figure><h2>상속, 다형성</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartimeStudent</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 Person 객체 포인터는 자식 클래스들을 받을수 있다.</span></span><br><span class="line"><span class="comment">// 이미 자기자신을 가르키는 파트가 있기때문이다.  이를 경우 Up Casting이라고 한다.</span></span><br><span class="line">Student P1 = Person; <span class="comment">//  단 만약에 Student만 존재하는 함수나 변수를 실행하면 에러 발생한다.</span></span><br><span class="line"><span class="comment">// 업캐스팅의 경우 여러 객체들을 동시처리할때 사용된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그외에 클라이언트 개발할때 다운캐스팅은 잘쓰면 엄청 좋다.</span></span><br><span class="line">Person P1 = (Person *)Student;</span><br><span class="line"><span class="comment">// CBaseObject라는 객체가 아이템, 플레이어 , 액션을 모두 담을수 있게 변수를 만든뒤 순수가상함수와 가상함수를 통해 연산을 할수 있도록 만들어둔다.</span></span><br><span class="line"><span class="comment">// 이와 같이 특정객체로 한정 지을떄 사용된다.</span></span><br></pre></td></tr></table></figure><h2>가상함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 오버라이딩 된 함수가 virtual 이라면, 오버라이딩 함수 또한 자동으로 virtual이어야만 한다.</span></span><br><span class="line"><span class="comment">// 부모클래스에서 자식클래스를 호출하고 싶을때, 가상함수가 좋은 방법이다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// virtual BB();  주석처리되어 있다면 A::BB()가 호출된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A *pa = <span class="keyword">new</span> A;</span><br><span class="line">A *pa2 = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 클래스안에 가상함수가 있다면 클래스 첫부분에 __vfptr이 생긴다.</span></span><br><span class="line"><span class="comment">// 모든 가상함수들이 테이블로써 리스트에 들어가게 된다. 하지만 이 메모리가 변조된다면, 끝장난다!!</span></span><br><span class="line"><span class="comment">// 그다가 가상함수 테이블은 공용이다 (같은 클래스 객체는 같이 사용) 이러니 문제가 미친듯이 터지게된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 문제가 생기면 일단 Pointer를 확인하고 가상함수 테이블을 확인! -&gt; 이런 문제는 찾기 너무 힘들다.</span></span><br><span class="line"><span class="comment">// 가상함수 테이블에서 주소와 함수이름이 안나온다면, 가상함수 테이블에 문제가 생긴거</span></span><br></pre></td></tr></table></figure><h2>순수 가상함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인터페이스 용도로써 사용하며, (외형 전달), 상속받은 클래스가 무조건 받아서 만들어줘야 한다.</span></span><br><span class="line"><span class="comment">// Down Casting 할때 너무 좋다.</span></span><br><span class="line"><span class="comment">// 순수 가상함수로 하는 이유는, 상속받은 클래스에 대해 이것을 필수조건으로 만들어준다.</span></span><br><span class="line"><span class="comment">// 라이브러리를 만들때, 자식 클래스에 연결하고 싶을때 사용한다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BB</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// virtual BB();  주석처리되어 있다면 컴파일 에러!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>가상 소멸자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up Cast 상황이든, Down Cast 상황이든, 상속관계에서 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">A *ptr = <span class="keyword">new</span> B; <span class="comment">// 을 선언했을때, </span></span><br><span class="line"><span class="comment">// 생성자는 B클래스를 했다. 만약 B클래스가 더 많은 맴버변수 및 함수를 가지고 있다면, 그 크기만큼 누수가 생긴다.</span></span><br><span class="line"><span class="comment">// 이를 해결하기 위해 가상소멸자를 사용한다.</span></span><br><span class="line"><span class="comment">// 그러면 생성된 B 클래스의 소멸자가 호출된다. -&gt; 이것또한 가상함수 테이블에 참조된다.</span></span><br></pre></td></tr></table></figure><h2>연산자 오버로딩</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;p2)</span><br><span class="line"><span class="comment">//-- 단항연산자(전위)</span></span><br><span class="line">Point&amp; <span class="keyword">operator</span>++(Point&amp; ref)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point&amp; <span class="keyword">operator</span>--(Point&amp; ref)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//--단항연산자(후위)</span></span><br><span class="line"><span class="keyword">const</span> Point <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Point <span class="title">retojb</span><span class="params">(x, y)</span></span>; <span class="comment">// 사본</span></span><br><span class="line">  x++;</span><br><span class="line">  y++;</span><br><span class="line">  <span class="keyword">return</span> retojb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout과 cin, endl도 오버로딩되어 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 오버로딩</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 메모리공간의 할당</span></span><br><span class="line"><span class="comment">2. 생성자의 호출</span></span><br><span class="line"><span class="comment">3. 할당하고자 하는 자료형에 맞게 주소값반환</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *ad = <span class="keyword">new</span> <span class="keyword">char</span>[size];  <span class="comment">// 연산자 오버로딩에서 다시 new 해도 된다.</span></span><br><span class="line">  <span class="keyword">return</span> adr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--&gt; delete 문제 // 하지만 delete 함수에서 delete 함수를 선언하면 안된다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> * adr)</span>  <span class="comment">// 이 함수가 호출이 안된다.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>템플릿</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 ,14 개념까지 들어가면 대박난다.</span></span><br><span class="line"><span class="comment">// 쉽게하자면 템플릿은 모든타입에 맞춰서 클래스나 함수를 만든다.</span></span><br><span class="line"><span class="comment">// 단 템플릿은 Intelisense가 정상적으로 동작되지않고,  정적바인딩에 속한다. (컴파일에 결정된다. -&gt; 가상함수는 동적바인딩이라고 할수있다. -&gt; 런타임에 결졍된다.)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // 원래 클래스가 쓰던 데이터타입을 <span class="title">T</span>로 바꿔주면된다.</span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class">* <span class="title">function</span> <span class="title">or</span> <span class="title">class</span> <span class="title">implement</span></span></span><br><span class="line"><span class="class">*</span></span><br><span class="line"><span class="class">*/</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SimpleTemplate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function">T <span class="title">Simplefunc</span><span class="params">(<span class="keyword">const</span> T&amp; ref)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T SimpleTemplate&lt;T&gt;::Simplefunc(<span class="keyword">const</span> T&amp; ref);</span><br></pre></td></tr></table></figure><h2>Exception</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> num2;  <span class="comment">// 수동으로 예외를 던진 케이스</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"~~~~"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 예외처리</span></span><br><span class="line"><span class="comment">// 예외발생시 catch를 통해 예외처리한다.</span></span><br><span class="line"><span class="comment">// 만약 예외발생시켯지만 아무도 catch하지않는다면 프로그래머가 선언안해도 있는 상위 catch를 통해 호출되고, 뻗는다. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack Unwinding(스택 풀기)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">throw</span> num2;</span><br><span class="line">   <span class="comment">// 예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가 전달된다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  Divide(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleFunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">      <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="keyword">char</span> expn)  <span class="comment">// 여기서 못받아서 위로 계속 올라간다.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//자료형이 일치하지 않으면 그 자료형에 맞는 catch가 나올때까지 위로 올라간다.</span></span><br><span class="line"><span class="comment">//하나의 try 영역 내에서 종류가 다른 둘 이상의 예외가 발생할 수 있기 때문에,</span></span><br><span class="line"><span class="comment">// 하나의 try 블록에 다수의 catch 블록을 추가할 수 있다.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 전달되는 예외의 명시</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ThrowFunc(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)&#123;&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">char</span> expn)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThrowFunc</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span> <span class="comment">// 함수 내에서 예외 데이터가 전달될 있음을 명시</span></span></span><br></pre></td></tr></table></figure><h2>스택 풀기</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stack Unwinding(스택 풀기)</span></span><br><span class="line"><span class="comment">//자료형이 일치하지 않으면 그 자료형에 맞는 catch가 나올때까지 위로 올라간다. -&gt; 이를 스택풀기라고 한다.</span></span><br></pre></td></tr></table></figure><h2>C++ Casting</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이제부터 습관들려야 할 캐스팅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static_cast</span></span><br><span class="line">  강제 형변환&lt;상속관계에서는 모두 허용해준다.&gt; 이외 말도 안되는거면 그냥 컴파일단계에서 무시한다.</span><br><span class="line"><span class="keyword">const_cast</span></span><br><span class="line">  <span class="keyword">const</span> 성향 제거</span><br><span class="line"><span class="keyword">dynamic_cast</span></span><br><span class="line">  상속관계에서의 안전한 형 변환 -&gt; 런타임시에 말도 안되는 포인터면 캐스팅 X <span class="literal">nullptr</span> 리턴</span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br><span class="line">  상관없는 자료형으로의 형 변환(C Style 캐스팅)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이 글은 C와 C++을 한권이라도 읽은 사람 대상으로 적었습니다. 개인 정리용에 가까우므로, 이걸로 공부하지마세요. !&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;메모리 구조&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="C, C++" scheme="https://Mutesk.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Game Server Programming 3</title>
    <link href="https://Mutesk.github.io/2018/02/22/GameServer2/"/>
    <id>https://Mutesk.github.io/2018/02/22/GameServer2/</id>
    <published>2018-02-22T05:29:26.459Z</published>
    <updated>2018-03-19T10:58:35.419Z</updated>
    
    <content type="html"><![CDATA[<h1>DB</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stateless 서버에서는 Statefull 서버와 달리 DB를 통해 데이터 저장하게 되고 , DB가 최신데이터가 된다.</span><br><span class="line"></span><br><span class="line">StateFull 서버는 Stateless 서버와 달리 메모리에 상주하고 잇는 데이터가 최신데이터이다 DB는 사실상 백업용이다.</span><br><span class="line"></span><br><span class="line">어떠한 행위일때마다 DB에 저장시키는 방식을 사용하자.</span><br><span class="line"></span><br><span class="line">요즘은 PCI Express X16 에다가 SSD 박아넣으니 DB를 Scale Up할 필요가 없다.</span><br></pre></td></tr></table></figure><h1>Scale Up, Scale Off</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Scale Up</th><th style="text-align:center">Scale Out</th><th style="text-align:center">Scale Out &amp; Up</th></tr></thead><tbody><tr><td style="text-align:center">개요</td><td style="text-align:center">기존 스토리지에 필요한 만큼의 용량 증가</td><td style="text-align:center">용량과 성능 요구조건에 맞추기 위해 Node 단위로 증가하고 하나의 시스템처럼 운영</td><td style="text-align:center">Sclae Up 아키텍쳐와 Scale Out 아키텍쳐를 합함</td></tr><tr><td style="text-align:center">비용</td><td style="text-align:center">컨트롤러나 네트워크 인프라 비용은 별도로 발생하지 않고 디스크만 추가됨.(상대적으로 비용이 적게 든다.)</td><td style="text-align:center">추가된 노드들이 하나의 시스템으로 운영되기 위한 NW 장비 필요. 컨트롤러도 추가</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">용량</td><td style="text-align:center">하나의 스토리지 컨트롤러에 붙일수 있는 Device 가 한정적, 용량확장에 제약</td><td style="text-align:center">Scale Up 형태의 스토리지보다는 용량 확장성이 크지만 무한대로 확장하지는 않음.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">성능</td><td style="text-align:center"></td><td style="text-align:center">Multple Storage Controller의 IOPS, 대역폭 등이 합친 성능이 나온다.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">복잡성</td><td style="text-align:center">심플한 구성</td><td style="text-align:center">상대적으로 복잡</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">가용성</td><td style="text-align:center"></td><td style="text-align:center">노드가 추가될수록 가용성 높아짐.</td><td style="text-align:center"></td></tr></tbody></table><h2>SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Struct Query Language 구조적 질의 언어</span><br></pre></td></tr></table></figure><h2>DB 설계</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB 테이블 설계는 칼럼을 늘려서 옆으로 늘리는것 보다. 다른 테이블을 통해 위로 세우는게 좋다. (성능 저하)</span><br></pre></td></tr></table></figure><ul><li>위로 세운다는 표현은 데이터 베이스 정규화작업(칼럼을 쪼갠다.)</li></ul><h2>트랜젝션</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DB에서의 처리 단위. 저장하는 과정에서 순차적으로 저장되어야 되는 상황에서 하나라도 중단되어 버린다면 전부 롤백한다.</span><br><span class="line"></span><br><span class="line">커밋을 하지 않으면 작업이 완료되지 않는다. 롤백됨.</span><br><span class="line">게임서버에서 주로 쓰는건 거래, 퀘스트 등이 있다.</span><br></pre></td></tr></table></figure><ul><li>중간에 물리적인 중단이 없다면, 굳이 필요가 없어져버린다.</li><li>트랜젝션은 오버헤드가 존재한다.</li><li>이게 말이 많은데, 미리 검증되어 있다면 트랜젝션이 필요 없다는 주장도 존재한다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    처리할 쿼리문들</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3>트랜젝션 동기화</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">트랜젝션도 자체적으로 동기화가 필요하다.</span><br><span class="line">같은 데이터의 Row 단위로 서로 다른 세션에서 트랜젝션으로 접근해도 락이 된다.</span><br><span class="line">SharedSRWLock 과 비슷하게 락이 걸린다. 즉 게임에서는 사용못함.</span><br></pre></td></tr></table></figure><ol><li>Lock Tables Syntax</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> <span class="string">`테이블명`</span> <span class="keyword">READ</span>; <span class="comment">/* 또는 Write */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   테이블 전체를 락 걸어버린다. READ로 락을 걸었다면 외부세션에서는 Select로 조회가 가능하다. </span></span><br><span class="line"><span class="comment">   데이터가 변경만 안되게 동기화를 맞춰주면 된다.</span></span><br><span class="line"><span class="comment">   WRITE 로 락을 걸었다면 외부에서 아예접근이 불가능하다. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">Tables</span></span><br></pre></td></tr></table></figure><ol start="2"><li>SelectForUpdate Syntax</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 가능한 이걸 권장한다.</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 테이블 <span class="keyword">where</span> 조건 <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 특정 행에서만 락을 건다. 해당 칼럼에 대해 Interlocked개념과 비슷하게 동작한다. 커밋이나 롤백하면 풀린다.</span></span><br></pre></td></tr></table></figure><h2>Table Tuning</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">애매하거나 속도 프로파일링을 원한다면 explain을 적어준다.</span><br><span class="line">type이 const라면 인덱스 개념으로 찾은거라 빠르다.</span><br><span class="line">       ALL이라면 지금 행을 전부 검색해서 찾은거라 매우 느리다. 인덱스를 쓰자. (이 형태는 ref로 나온다.)</span><br><span class="line">    </span><br><span class="line">하지만 인덱스일경우 삽입 삭제가 빈번하면 느려진다는 단점이 있다.</span><br></pre></td></tr></table></figure><h2>Scale Out</h2><ul><li>애초에 DB는 샤딩이 가능하게 만들어야 된다.(해쉬같은 느낌으로 저장한다.)</li><li>게임 DB를 동일한 테이블들로 만든뒤 이걸 여러개로 나눈다.</li><li>게임에는 DB분산은 그렇게 좋지 않다.</li></ul><h3>Sharding</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법을 말한다.</span><br></pre></td></tr></table></figure><p><a href="http://d2.naver.com/helloworld/14822" target="_blank" rel="noopener">샤딩 NHN 문서</a></p><h2>저장 프로시저(Stored Procedure)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다.</span><br></pre></td></tr></table></figure><h3>장점</h3><ol><li>하나의 요청으로 여러 SQL 문을 실행할수 있다.</li><li>DB 트리거와 결합하여 복잡한 규칙에 의한 데이터의 참조무결성 유지가 가능하게 된다.</li></ol><h3>단점</h3><ol><li>호환성이 낮아서 재사용성이 나쁘다.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;DB&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="GameServer, DB" scheme="https://Mutesk.github.io/tags/GameServer-DB/"/>
    
  </entry>
  
</feed>
