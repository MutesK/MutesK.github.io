<!DOCTYPE html><html lang="ko-KR"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JunMin Kim, j0803@naver.com"><title>Effective C++ Chapter2 · Mute의 개발 블로그</title><meta name="description" content="Item 5. C++가 은근슬쩍 만들어서 호출하는 함수에 대해 촉각을 세우자.
복사 생성자, 복사 대입 생성자, 기본생성, 소멸자을 기본으로 만들고 전부 public 접근 지정자이며 inline 함수이다.

기본 생성과 소멸자인경우, 컴파일러에게 코드를 깔수 있는 자리"><meta name="keywords" content="C++,C,PHP,Windows OS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mute의 개발 블로그</a></h3><div class="description"><p>게임 서버 개발 및 각종개발기술 공부</p></div></div></div><ul class="social-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://github.com/MutesK"><i class="fa fa-github"></i></a></li></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">홈</a></li><li><a href="/about">정보</a></li><li><a href="/archives">아카이브</a></li><li><a href="/links">포트폴리오 링크</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Effective C++ Chapter2</a></h3></div><div class="post-content"><h1 id="Item-5-C-가-은근슬쩍-만들어서-호출하는-함수에-대해-촉각을-세우자"><a href="#Item-5-C-가-은근슬쩍-만들어서-호출하는-함수에-대해-촉각을-세우자" class="headerlink" title="Item 5. C++가 은근슬쩍 만들어서 호출하는 함수에 대해 촉각을 세우자."></a>Item 5. C++가 은근슬쩍 만들어서 호출하는 함수에 대해 촉각을 세우자.</h1><blockquote>
<p>복사 생성자, 복사 대입 생성자, 기본생성, 소멸자을 기본으로 만들고 전부 public 접근 지정자이며 inline 함수이다.</p>
</blockquote>
<p>기본 생성과 소멸자인경우, 컴파일러에게 코드를 깔수 있는 자리를 마련해준다.<br>만약 상속관계에서의 소멸자인경우, 상속한 클래스가 가상소멸자 선언을 안되어 있다면 비가상 소멸자로 만들어진다.<br>복사생성자와 복사 대입생성자가 기본으로 생성되는 경우에는, 원본 객체의 비정적 데이터를 사본으로 그저 복사할뿐이다. (얇은 복사)</p>
<p><strong><em>결정적으로 복사 대입 연산자를 private로 선언한 기본 클래스로부터 파생된 클래스인 경우, 암시적 복사 대입 연산자를 가질수 없다.</em></strong></p>
<p>파생 클래스에 대해 컴파일러가 만들어주는 복사 대입 연산자는 기본 클래스 부분을 맡도록 되어 있도록 되어 있긴하지만, 이렇게 하더라도 파생클래스에서 호출할 권한이 없는 맴버 함수는 암시적 복사 대입 연산자가 어떻게 호출할수 없다.</p>
<blockquote>
<p>컴파일러가 파생클래스의 생성한 복사 함수(복사생성, 복사 대입)는 기본 클래스의 대응 버전을 호출하도록 되어 있는다는 점!</p>
</blockquote>
<h1 id="Item-6-컴파일러가-만들어낸-함수가-필요없다면-확실히-이들의-사용을-금해버리자"><a href="#Item-6-컴파일러가-만들어낸-함수가-필요없다면-확실히-이들의-사용을-금해버리자" class="headerlink" title="Item 6. 컴파일러가 만들어낸 함수가 필요없다면 확실히 이들의 사용을 금해버리자."></a>Item 6. 컴파일러가 만들어낸 함수가 필요없다면 확실히 이들의 사용을 금해버리자.</h1><blockquote>
<p>컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 맴버 함수를 private로 선언한뒤 구현을 하지않은채로 두면된다.<br>또는 Uncopyable라는 클래스를 만들고 private 로 상속시키는 것도 방법</p>
</blockquote>
<h1 id="Item-7-다형성을-가진-기본-클래스에서는-소멸자를-반드시-가상-소멸자로-선언하자"><a href="#Item-7-다형성을-가진-기본-클래스에서는-소멸자를-반드시-가상-소멸자로-선언하자" class="headerlink" title="Item 7. 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자."></a>Item 7. 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자.</h1><blockquote>
<p>문제는 포인터가 가르키는 객체의 타입에 맞춰서 삭제된다는 점인데, 비가상 소멸자가 들어 있다면 파생 클래스 객체가 삭제될때,<br>프로그램의 동작은 미정의 사항이라고 되어 있다. 대게 그 객체의 파생 클래스 부분이 소멸되지 않게 된다. // 소멸자를 호출할때, 기준의 포인터 형태가 중요</p>
</blockquote>
<p><strong><em>가상 소멸자를 선언하는 것은 그 클래스에 가상함수가 하나라도 들어있는 경우에만 한정하자.</em></strong></p>
<p>기본클래스로 설계되지 않았거나 다형성을 갖도록 설계되지않은 클래스에는 가상소멸자를 선언하지 말아야 됩니다. - 파생 클래스의 소멸자가 호출되지 않게됩니다.</p>
<h1 id="Item-8-예외가-소멸자를-떠나지-못하도록-붙들어-놓자"><a href="#Item-8-예외가-소멸자를-떠나지-못하도록-붙들어-놓자" class="headerlink" title="Item 8. 예외가 소멸자를 떠나지 못하도록 붙들어 놓자."></a>Item 8. 예외가 소멸자를 떠나지 못하도록 붙들어 놓자.</h1><blockquote>
<p>만약 vector가 있을때, 벡터의 타입은 어떤 클래스의 인스턴스인 상황에서, 첫번째 것을 소멸시키는 도중에 예외가 발생하였고, 다음 나머지 객체들의 소멸을 위해 소멸자를 호출하고 이때 또 예외가 나온다면 활성화된 예외가 2개 이상인 상황이면, C++에서 감당하기 버거워진다.</p>
</blockquote>
<p><strong>걱정처리를 피하는 방법 1 프로그램을 바로 끝낸다.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	~~~</span><br><span class="line">&#125; <span class="keyword">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// close 로그 작성</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>걱정거리를 피하는 방법2. 예외를 삼겨버린다.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	~~~</span><br><span class="line">&#125; <span class="keyword">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// close 로그 작성</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>예외 삼키기는 그리 좋진 않다. 그저 로그만 알려줄뿐이다. 2번째 선택이 빛을 발하기 위해서는 예외를 무시하더라도 신뢰성있게 실행을 지속할수 있어야만 된다.<br>더 좋은 방법으로는, 예외가 소멸자가 아닌 다른 함수에서 비롯된 것이어야 된다. 소멸자는 프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문에<br>close함수를 따로만들어서 호출시킨다면, 사용자에게 에러를 처리할수 있는 기회를 주게된다.</p>
<h1 id="Item-9-객체-생성-및-소멸-과정에서는-가상함수를-호출하지-말자"><a href="#Item-9-객체-생성-및-소멸-과정에서는-가상함수를-호출하지-말자" class="headerlink" title="Item 9. 객체 생성 및 소멸 과정에서는 가상함수를 호출하지 말자."></a>Item 9. 객체 생성 및 소멸 과정에서는 가상함수를 호출하지 말자.</h1><p>호출결과가 원하는대로 돌아가지 않기 때문.<br>상속관계에서의 생성자 호출은 기본 클래스의 생성자 다음에 파생 클래스의 생성자가 호출되는데, 기본 클래스 생성자가 돌아가고 있을때 어쩌다가 가상함수를 호출하게되고,<br>파생 클래스 쪽을 건들이게 된다면, 아직 파생클래스는 초기화되지 않은 상황이라 어떻게 될지 모르는 상황이 온다.</p>
<p>파생 클래스 객체의 기본 클래스 부분이 생성되는 동안, 그 객체의 타입은 바로 기본 클래스.<br>호출되는 가상 함수는 모두 기본 클래스의 것으로 resolve(결정)될 뿐만 아니라, 런타임 타입 정보를 사용하는 언어 요소를 사용한다고 해도,<br>이순간에는 기본 클래스 타입으로 취급된다.</p>
<h1 id="Item-10-대입-연산자는-this-참조자를-반환하게-하자"><a href="#Item-10-대입-연산자는-this-참조자를-반환하게-하자" class="headerlink" title="Item 10. 대입 연산자는 *this 참조자를 반환하게 하자."></a>Item 10. 대입 연산자는 *this 참조자를 반환하게 하자.</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Item-11-operator-에서는-자기대입에-대한-처리가-빠지지-않도록-하자"><a href="#Item-11-operator-에서는-자기대입에-대한-처리가-빠지지-않도록-하자" class="headerlink" title="Item 11. operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자."></a>Item 11. operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자.</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>수많이 대입이 일어난다면, 처리가 느려진다. 이때의 기법이 Copy and Swap.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Widget Temp(rhs); <span class="comment">// rhs에 대해 사본 -&gt; 복사생성자</span></span><br><span class="line">	swap(temp); <span class="comment">// *this와 temp을 맞바꾼다.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>두 개 이상의 객체 대해 동작하는 함수가 있다면 이 함수에 넘겨지는 객체들이 사실<br>같은 객체인지 확인!</p>
<h1 id="Item-12-객체의-모든-부분을-빠짐없이-복사하자"><a href="#Item-12-객체의-모든-부분을-빠짐없이-복사하자" class="headerlink" title="Item 12. 객체의 모든 부분을 빠짐없이 복사하자."></a>Item 12. 객체의 모든 부분을 빠짐없이 복사하자.</h1><blockquote>
<p>객체 복사 함수는 주어진 객체의 모든 데이터 맴버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사한다.</p>
</blockquote>
<p>클래스의 복사 함수 2개 를 구현할때, 한쪽을 이용해서 다른쪽을 구현하려고 하지마라.<br>그 대신 공통된 동작을 제 3의 함수에 분리해 놓고 양쪽에서 호출해서 해결.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/C/" title="C++">C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://Mutesk.github.io/2018/03/30/Effective-C-Chapter-2/,Mute의 개발 블로그,Effective C++ Chapter2,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/03/31/cpp-class-size/" title="C++에서의 클래스 크기, sizeof">이전 포스트</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/03/30/STL-Chatper-2-2/" title="Vector 컨테이너, deque 컨테이너, list 컨테이너">다음 포스트</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify: || false, 
  verify:|| false, 
  app_id:'',
  app_key:'',
  placeholder:'',
  path: window.location.pathname,
  avatar:''
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>