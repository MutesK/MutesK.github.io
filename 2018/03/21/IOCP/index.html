<!DOCTYPE html><html lang="ko-KR"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JunMin Kim, j0803@naver.com"><title>IOCP에 대해 · Mute의 개발 블로그</title><meta name="description" content="입출력 완료 포트(IOCP)비동기 입출력과 완료 포트를 이용하고, 스레드를 효율적으로 관리하며, GQCS에 의해 필요한 스레드만이 깨어난다.

APC 큐는 스레드 별로 확인할수 있지만, IOCP는 제약이 없다.


입출력 완료 포트는 CreateIoCompletionP"><meta name="keywords" content="C++,C,PHP,Windows OS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mute의 개발 블로그</a></h3><div class="description"><p>게임 서버 개발 및 각종개발기술 공부</p></div></div></div><ul class="social-links"><li><a href="http://github.com/MutesK"><i class="fa fa-github"></i></a></li></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">홈</a></li><li><a href="/about">정보</a></li><li><a href="/archives">아카이브</a></li><li><a href="/links">포트폴리오 링크</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>IOCP에 대해</a></h3></div><div class="post-content"><h1 id="입출력-완료-포트-IOCP"><a href="#입출력-완료-포트-IOCP" class="headerlink" title="입출력 완료 포트(IOCP)"></a>입출력 완료 포트(IOCP)</h1><p><em>비동기 입출력과 완료 포트를 이용하고, 스레드를 효율적으로 관리하며, GQCS에 의해 필요한 스레드만이 깨어난다.</em></p>
<blockquote>
<p>APC 큐는 스레드 별로 확인할수 있지만, IOCP는 제약이 없다.</p>
</blockquote>
<ol>
<li>입출력 완료 포트는 CreateIoCompletionPort()을 통해 생성하고, CloseHandle로 파괴한다.</li>
<li>입출력 완료 포트에 접근하는 스레드를 별로도 두는데, 이를 작업자 스레드라고 부르며, 이를 관리해준다.</li>
<li>입출력 완료 포트에 저장된 결과를 처리하려면 GetQueuedCompletionStatus() 함수를 통해 처리한다.</li>
</ol>
<h2 id="동작원리"><a href="#동작원리" class="headerlink" title="동작원리"></a>동작원리</h2><ol>
<li>응용 프로그램을 구성하는 임의의 스레드에서 비동기 입출력 함수를 호출함으로써 OS 입출력 작업을 요청한다.</li>
<li>모든 작업자 스레드는 GQCS 함수를 호출하여 입출력 완료 포트를 감시한다. 완료된 비동기 입출력 작업이 아직 없다면, 모든 작업자 스레드는 대기 상태가 된다. 이때 대기 중인 작업자 스레드 목록은 입출력 완료 포트 내부에 저장된다.</li>
<li>비동기 입출력 작업이 완료되면, 운영체제는 입출력 완료 포트에 결과를 저정한다. 이때 저장되는 정보를 입출력 완료 패킷이라고 부른다.</li>
<li>운영체제는 입출력 완료 포트에 저장된 작업자 스레드 목록에서 하나를 선택하여 깨운다. 깨어난 작업자 스레드는 비동기 입출력 결과를 처리한다. 이후 작업자 스레드는 필요에 따라, 다시 비동기 입출력 함수를 호출할수 있다.</li>
</ol>
<h2 id="Example-Note"><a href="#Example-Note" class="headerlink" title="Example Note"></a>Example Note</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">&lt;포함&gt;</span><br><span class="line">클라이언트</span><br><span class="line">&#123;</span><br><span class="line">    SOCKET socket;</span><br><span class="line">    OVERLAPPED Recv;</span><br><span class="line">    OVERLAPPED Send;</span><br><span class="line">    SendQ</span><br><span class="line">    RecvQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">&lt;확장&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOverlapped</span> :</span> <span class="keyword">public</span> OVERLAPPED</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> Mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ConnectedFail =&gt; Connect Queue가 넘쳣을때 - Accept에서 제대로 못빼고있다. =&gt; Accept Thread는 Accept만 처리하게 만들거다.</span><br><span class="line"><span class="comment">// IOCP 핸들</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 워커스레드</span></span><br><span class="line">IOCP 모델에서 PostQueuedCompletionStatus(IOCP, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); 을 넣어서 종료시킨다.</span><br><span class="line">종료 시점</span><br><span class="line">    모든 클라이언트가 정상 종료가 되었다는것을 확인뒤에 종료시킨다.</span><br><span class="line"></span><br><span class="line">-&gt; LPOVERLAPPED, Key, Transfered 변수가 전부 <span class="number">0</span>이라면 정상적으로 워커스레드를 종료시키면된다. </span><br><span class="line"></span><br><span class="line">GetQueuedCompletionStatus에서 LPOVERLAPPED 가 Nullptr || Transfer = <span class="number">0</span>로 나왓다면 에러 상황이다. -&gt; 종료시키자. (물론 로그는 남겨야.. )</span><br><span class="line"></span><br><span class="line">ERROR_NETNAME_DELETE -&gt; 이런 예외처리도 존재한다(해당 소켓이 갑자기 <span class="number">4</span> Way HandShake 없이 끊어진상태 그냥 closesocket만 해주자. 실제로는 이렇게 처리안해줘도 된다.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO Reference Count 방식을 통해 </span><br><span class="line"></span><br><span class="line">Session </span><br><span class="line">&#123;</span><br><span class="line">    Client;</span><br><span class="line">    IOCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IOCount의 증감, 감소를 위해 Interlocked함수 계열을 써야된다.</span></span><br><span class="line"><span class="comment">// 이 세션을 종료시킬 조건은 IOCount = 0일때</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IOCount는 처리하기전에 먼저 올려야된다. -&gt; 큐에 올라가버린다.</span><br><span class="line">에러가 떳는데 IO_PENDING 아니라면 완료 통지가 안오니까 IO--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO 완료되었을때 <span class="number">1</span> 감소시키는데 감소시키는 시점은 </span><br><span class="line">Recv 완료, Send 완료시에 IO차감 시킨다.</span><br><span class="line">IOCount는 초기화는 맨처음에만 한다.</span><br><span class="line"></span><br><span class="line">WorkerThread()</span><br><span class="line">&#123;</span><br><span class="line">    GQCS()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Recv 종료라면)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IO차감</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recv 재등록</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Send 종료라면)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IO차감</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send 재등록</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 차감하는 곳에는 모두 이렇게 들어간다.</span></span><br><span class="line">IO--;</span><br><span class="line"><span class="keyword">if</span>(IO &lt;= <span class="number">0</span>)</span><br><span class="line">    Release();  <span class="comment">// -&gt; 이러면 릴리즈가 2번 걸릴수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 차감을 </span></span><br><span class="line"><span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Release();   <span class="comment">// 외부스레드에서  따로 막아야된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread1(-)</span><br><span class="line">&#123;</span><br><span class="line">    IO++;</span><br><span class="line">    WSARecv();</span><br><span class="line">    <span class="keyword">if</span>(에러)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Release();   <span class="comment">// 외부스레드에서  따로 막아야된다.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerThread(-)</span><br><span class="line">&#123;</span><br><span class="line">    GQCS(-)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(InterlockedDecrement(IOCount) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">           Release();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이렇게 모든 IO 참조카운트방식의 감소할때는 릴리즈도할수있게 만들어줘야된다.</span></span><br><span class="line"></span><br><span class="line">closesocket </span><br><span class="line">    윈도우 객체 핸들이니깐, 리소스핸들 반환도 한다. GQCS에서 등록된 소켓을 closesocket을 했다면 GQCS 오류로 처리된다.</span><br><span class="line">    -&gt; 소켓 번호는 재사용된다. (그 순간 Accept 된다면 같은 소켓번호를 등록해버린다. <span class="comment">///) -&gt; 예전 꺼의 작업완료통지가 안와버린다.</span></span><br><span class="line">    -&gt; 끊고싶다면 Release()로 하는게 안전함.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIME_WAIT이 왜뜨고 어디에 남는가?</span><br><span class="line"> TCP 상태의 가장 마지막 단계.</span><br><span class="line"></span><br><span class="line">        A                                       B</span><br><span class="line">(FIN_WAIT1)    -&gt;       FIN 보낸다.    -&gt;              (LAST_ACK)</span><br><span class="line"></span><br><span class="line">(TIME_WAIT)    &lt;-     FIN,ACK를 보낸다.  &lt;-            (LAST_ACK)</span><br><span class="line">                (이쪽에서 TIME_WAIT 상태가 된다.)</span><br><span class="line">             -&gt;         ACK를 보낸다.    -&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             &lt;!!!!!!!!!!!! 접속 종료 !!!!!!!!!!!!&gt;</span><br><span class="line"></span><br><span class="line">TIME_WAIT을 안걸리기 위해서</span><br><span class="line">SO_LINGER 옵션을 주고 끊어야 된다.</span><br><span class="line"></span><br><span class="line">-&gt; TIME_WAIT의 문제 : 리소스 문제(포트, 커널)</span><br><span class="line"></span><br><span class="line">Shutdown -&gt; FIN을 넘긴다. -&gt; 우리는 TIME_WAIT을 포기한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">======================================================================================================================================================</span><br><span class="line"></span><br><span class="line">Client</span><br><span class="line">&#123;</span><br><span class="line">    OVERLAPPED      Recv;</span><br><span class="line">    OVERLAPPED      Send;</span><br><span class="line"></span><br><span class="line">    CStreamQ        SendQ;</span><br><span class="line">    CStreamQ        RecvQ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>            SendFlag;       <span class="comment">// 지금 Send를 보내고 있는지 확인 (Interlocked함수 써야된다.)</span></span><br><span class="line">    DWORD           IOCount;        <span class="comment">// 여기도 Interlocked함수 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;  완료 통지에 대해선 순서가 없다. </span><br><span class="line">==&gt;  Transfered 변수가 있다라는건 Send 후에 완료 통지를 보고 버퍼 위치를 옮기면 된다. =&gt; 완전히 보낼때까지 완료 통지가 안온다.</span><br><span class="line">==&gt;  링버퍼 존재가 달라졌다.</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Winsock/" title="Winsock">Winsock </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://Mutesk.github.io/2018/03/21/IOCP/,Mute의 개발 블로그,IOCP에 대해,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/03/21/OverlappedIO/" title="Overlapped I/O">다음 포스트</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify: || false, 
  verify:|| false, 
  app_id:'',
  app_key:'',
  placeholder:'',
  path: window.location.pathname,
  avatar:''
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>