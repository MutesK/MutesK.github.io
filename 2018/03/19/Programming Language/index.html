<!DOCTYPE html><html lang="ko-KR"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JunMin Kim, j0803@naver.com"><title>Programming Language(C/C++) · Mute의 개발 블로그</title><!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="description" content="[TOC]
이 글은 C와 C++을 한권이라도 읽은 사람 대상으로 적었습니다. 개인 정리용에 가까우므로, 이걸로 공부하지마세요. !
메모리 구조


CODE
함수, 제어문, 상수 영역(컴파일시 결정)




DATA
전역 변수(컴파일시 결정)


BSS
초기화값이 없는 "><meta name="keywords" content="C++,C,PHP,Windows OS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Mute의 개발 블로그</a></h3><div class="description"><p>게임 서버 개발 및 각종개발기술 공부</p></div></div></div><ul class="social-links"><li><a href="http://github.com/MutesK"><i class="fa fa-github"></i></a></li></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">홈</a></li><li><a href="/about">정보</a></li><li><a href="/archives">아카이브</a></li><li><a href="/links">포트폴리오 링크</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Programming Language(C/C++)</a></h3></div><div class="post-content"><hr>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>[TOC]</p>
<p><em>이 글은 C와 C++을 한권이라도 읽은 사람 대상으로 적었습니다. 개인 정리용에 가까우므로, 이걸로 공부하지마세요. !</em></p>
<h2 id="메모리-구조"><a href="#메모리-구조" class="headerlink" title="메모리 구조"></a>메모리 구조</h2><table>
<thead>
<tr>
<th style="text-align:center">CODE</th>
<th style="text-align:center">함수, 제어문, 상수 영역(컴파일시 결정)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>DATA</strong></td>
<td style="text-align:center"><strong>전역 변수(컴파일시 결정)</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>BSS</strong></td>
<td style="text-align:center"><strong>초기화값이 없는 전역변수(컴파일시 결정)</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>HEAP</strong></td>
<td style="text-align:center"><strong>동적 할당(런타임)</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>Stack</strong></td>
<td style="text-align:center"><strong>지역 변수(런타임)</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>스택에서 자료(로컬변수)를 만지는게 제일 빠르다.  </li>
<li>가능한 전역변수는 사용하지않는게 속도상에서 좋다.</li>
<li>동적할당은 어느정도되면 안만들어진다. 32비트 컴퓨터일경우 (1.98G)</li>
</ul>
<h2 id="전처리기"><a href="#전처리기" class="headerlink" title="전처리기"></a>전처리기</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__DATA__ <span class="comment">// 컴파일 날짜를 나타내는 문자열 </span></span><br><span class="line">__TIME__ <span class="comment">// 현재 시간 문자열</span></span><br><span class="line">__FILE__ <span class="comment">// 파일 이름 포함 문자열</span></span><br><span class="line">__LINE__ <span class="comment">// 지금 현재 라인수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건부 컴파일</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> X</span></span><br><span class="line">    <span class="comment">// - #define이 되어있다면 처리한다.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 안되어있다면 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> #<span class="meta-keyword">if</span>문 종료</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> X</span></span><br><span class="line">     <span class="comment">// #define X이 안되어있다면 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">//#elif   = else if</span></span></span><br><span class="line">    <span class="comment">// 되어 있다면</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">assert(<span class="comment">/* bool statement */</span>) <span class="comment">// 수식의 값이 기대하고 있는 값인가 확인할때 사용 -&gt; 실패하면 메세지 출력후 중단해버림.</span></span><br></pre></td></tr></table></figure>
<h2 id="함수-호출-스택"><a href="#함수-호출-스택" class="headerlink" title="함수 호출 스택"></a>함수 호출 스택</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug 중 일때, BreakPoint를 통해 인터럽트를 걸어주면(멈추게 하면), 함수 스택이 있다.</span><br><span class="line">영어로는 Call Stack이라고 하고, 사용하는 이유는, 현재 실행중인 서브루틴(함수)를 실행하고 어디로 돌아가야할지 절차들을 따르기 위함이다. ( Recursive : 재귀 연산할때 잘못하면 Stack Overflow가 뜨는 이유)</span><br><span class="line"></span><br><span class="line">&lt;Tip 1&gt;</span><br><span class="line">static 변수는 가능한 쓰지 않은게 좋은데, 이 변수는 다른 소스파일에서 extern으로 가져오려고 해도 메모리가 따로 할당받아진다. (cpp에서 선언한 변수 다른 cpp에서 사용하고싶을때의 상황)</span><br></pre></td></tr></table></figure>
<h2 id="바이트-순서"><a href="#바이트-순서" class="headerlink" title="바이트 순서"></a>바이트 순서</h2><ul>
<li><p>빅 엔디안은 큰 단위의 바이트가 앞에 오는 방식, 리틀엔디안은 작은 단위의 바이트가 뒤에 오는 방식이다.</p>
</li>
<li><p>네트워크 장비들은 빅 엔디안을 쓰고, 우리와 같은 PC는 리틀 엔디안 식으로 저장한다.</p>
<p><img src="PC의 리틀엔디안 저장.png" alt=""></p>
</li>
</ul>
<h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 접근 자료 크기 */</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">short</span> *p3 = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">p1++; <span class="comment">// p1 = 0x1004  // 접근하는 크기만큼 더해진다. sizeof(자료형 *)</span></span><br><span class="line">p2++; <span class="comment">// p2 = 0x1001</span></span><br><span class="line">p3++; <span class="comment">// p3 = 0x1002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 32bit에서는 Pointer의 크기는 4 Bytes, 64bit에서는 8 Bytes이며, 접근하는 크기는 각 자료형에 따라 다르다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 리틀 엔디안의 포인터 */</span></span><br><span class="line"><span class="keyword">char</span> Buffer[<span class="number">10</span>]; <span class="comment">// 0x11 0x22 0x33 0x44 ... 가 들어있을때..</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)buffer;</span><br><span class="line"><span class="keyword">int</span> a = *p;<span class="comment">//를 할경우 0x44332211으로 저장된다.(리틀 엔디안)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0xffffff00</span>; </span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">char</span> x = *p; <span class="comment">// 딱 1만 가져온다. 1바이트 크기만큼 x는 0x00만 가지고 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">short</span> x = *p; <span class="comment">// 이 경우 x 는 0xff00을 가지고있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 배열 인덱싱 */</span></span><br><span class="line">*(p + <span class="number">1</span>) = p[<span class="number">1</span>]; <span class="comment">// 포인터 p에서 포인터의 크기만큼 1 * (32일때 4, 64일때 8) 씩 이동한다.</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = *(*(a + <span class="number">1</span>) + <span class="number">2</span>) <span class="comment">// 2차원 배열 같은 경우 한칸 아래 옆 2칸이므로,</span></span><br><span class="line">    <span class="comment">// a + (1 * 최대 열수 * 32일때 4, 64일때 8) + (2 * (32일때 4, 64일때 8)) 씩 움직인다.</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* void형 포인터 */</span></span><br><span class="line"><span class="comment">// 아무거나 가르킬 용도로 쓴다. 캐스팅 전용 포인터. 대부분 책에서 추천하지않은 이유가 이 포인터의 자료형을 모를때 무슨일이 일어날지 모른다. 오버해서 캐스팅하면 Corruption이 일어난다. (다른 자료에 까지 Write 할수도 있음.)</span></span><br></pre></td></tr></table></figure>
<h2 id="Const-Pointer"><a href="#Const-Pointer" class="headerlink" title="Const Pointer"></a>Const Pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C/C++ 사용하면서 조낸 헤깔린다</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 일때 const가 맨 앞에 있으면 화살표를 뒤로 그려서 num을 가르켜서 num을 상수화한다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr1 = &amp;val1; <span class="comment">// 일때 const가 맨앞이니 역시나 화살표 그리면 ptr1을 가르킨다. ptr1은 int *형이기 때문에 ptr1을 통해 val1은 수정하지못한다. ptr1은 수정가능!</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;val1; <span class="comment">// 이경우 const는 중간에 있으니 뒤로 화살표 그리면 ptr1을 가르키고, 그 뜻은 ptr1은 수정 불가능이 된다. 단 val1은 수정가능!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;val1; <span class="comment">// 앞에 있는 const는 val1을 상수화, 중간에 있는 const는 ptr1을 상수화한다. 둘다 수정 불가능!</span></span><br></pre></td></tr></table></figure>
<h2 id="Function-Pointer"><a href="#Function-Pointer" class="headerlink" title="Function Pointer"></a>Function Pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 콜백함수처럼 사용하는 방법 중 하나인 함수포인터이다.</span></span><br><span class="line"><span class="comment">// 함수도 메모리를 가진다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">void Test(void (*ptr) (void))</span><br><span class="line">&#123;</span><br><span class="line">    ptr();  <span class="comment">// Draw의 시작주소를 통해 호출!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*ptr1) (<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> c); <span class="comment">// 함수 포인터 변수 선언</span></span><br><span class="line">    ptr1 = function; <span class="comment">// 함수 포인터에 함수 시작주소 넣음.</span></span><br><span class="line">    </span><br><span class="line">    ptr1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// function(1,2,3) 이 호출된다.</span></span><br><span class="line">    Test(Draw);  <span class="comment">// Draw 전역 함수를 매개변수로 넘긴다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="구조체"><a href="#구조체" class="headerlink" title="구조체"></a>구조체</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 규약이 발전하면서 구조체랑 클래스랑 다른건 접근지정자 말곤 없는것 같다.</span></span><br><span class="line"><span class="comment">// 클래스는 기본 private, 구조체는 public 이다.</span></span><br><span class="line"><span class="comment">// 구조체 바이트 정렬이 중요하다.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 이렇게 있을때, Test는 1 + 4 = 5 바이트를 가지고 있지않다.</span></span><br><span class="line"><span class="comment">// 컴파일러가 구조체 정렬할때 가장 큰 자료형 기준으로 정렬한다.</span></span><br><span class="line"><span class="comment">// int가 제일 크므로 int + int = 8바이트</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)  <span class="comment">// 정렬 크기를 1바이트</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="comment">// 이 경우 5바이트가 나온다. 정렬 기법은 대부분 사용하지않지만, _aligned_malloc 같은 물리적으로 연속할당이 필수적인 상황이 있는데, 그 경우에 사용해야된다.&lt;거의 잘안씀.&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="인라인"><a href="#인라인" class="headerlink" title="인라인"></a>인라인</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C에서의 매크로함수의 단점을 달피하고자 나왔다.</span><br><span class="line">함수 선언 앞에 inline을 쓰면된다. 그리고 헤더에 넣어야 한다.</span><br><span class="line">컴파일러가 최적화 해주는데 visual studio에서 컴파일러 최적화 옵션을 켜야만 동작한다. 껏다면 일반 함수.</span><br><span class="line">프로그래머가 인라인화 하더라도 컴파일러가 거부하면 일반함수로 된다.</span><br></pre></td></tr></table></figure>
<h2 id="정보은닉-캡슐화"><a href="#정보은닉-캡슐화" class="headerlink" title="정보은닉, 캡슐화"></a>정보은닉, 캡슐화</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">대부분 책에서는 정보은닉 및 캡슐화 예제를 적어놓고</span><br><span class="line"></span><br><span class="line">GetX, SetX 같은 함수를 만드는데 이럴경우 의미가 없어진다.</span><br><span class="line">Move함수를 만들어서 내부 변수만 움직이게 해주는게 좋다.</span><br><span class="line"></span><br><span class="line">&lt;Tip 2&gt;</span><br><span class="line">class 안에 맴버함수로 const를 넣게 되면, class 의 내부 변수를 만질수 없다.</span><br><span class="line">const 함수 안에서는 일반 함수또한 호출할수 없다. (const 끼리 호출가능하다.)</span><br></pre></td></tr></table></figure>
<h2 id="생성자-소멸자"><a href="#생성자-소멸자" class="headerlink" title="생성자, 소멸자"></a>생성자, 소멸자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자</span></span><br><span class="line"><span class="comment">//Object Instance가 Alloc 될때 호출된다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BB(<span class="keyword">int</span> X)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">BB <span class="title">Data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 위 코드를 어셈블로 보자면, </span></span><br><span class="line"><span class="comment">// push 0</span></span><br><span class="line"><span class="comment">// lea ecx, [Data]</span></span><br><span class="line"><span class="comment">// 클래스 객체 대해서의 데이터 확보는 함수 호출시에 확보 되지만, 생성자는 바로 호출되지 않는다.</span></span><br><span class="line"><span class="comment">// 호출되는 순간은, 해당라인이 지나갈때 호출된다.</span></span><br><span class="line"><span class="comment">// 가능하면 if ~ else 로 두개의 객체를 선언하면 좋지않음.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 파괴자</span></span><br><span class="line"><span class="comment">// 함수를 빠져나오거나, delete가 선언되었을때 호출된다.</span></span><br><span class="line"><span class="comment">// 맴버함수로써 사용가능(생성자는 불가능) -&gt; 임의 호출은 좋지않다.</span></span><br></pre></td></tr></table></figure>
<h2 id="Placement-New"><a href="#Placement-New" class="headerlink" title="Placement New"></a>Placement New</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc으로 생성한 객체를 생성자따로 호출할 방법이 바로 Placement New이다. */</span></span><br><span class="line">BB *px = (BB *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BB));</span><br><span class="line">BB *p3 = <span class="keyword">new</span> (px) BB; <span class="comment">// Placement New - 참고로 px와 p3은 같다. new해서 받은 리턴값을 굳이 안받아도 된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 단 이럴경우 delete로 호출할수 없으며</span></span><br><span class="line"><span class="built_in">free</span>(px); <span class="comment">// 이럴경우도 문제가 생긴다.</span></span><br><span class="line"></span><br><span class="line">px-&gt;~BB(); <span class="comment">// 소멸자를 호출해서 파괴시켜야된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 재미난 캐스팅 -&gt; 잘 안쓰지만 C++가 시발 존나 어려운 이유 중 하나</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10000</span>];</span><br><span class="line">BB *px = <span class="keyword">new</span> (A) BB; <span class="comment">// int 배열 A를 메모리 공간으로 쓴다.</span></span><br><span class="line">px-&gt;~BB(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Array[<span class="number">100</span>];</span><br><span class="line">CPlayer *p = (CPlayer *)Array; <span class="comment">// Placement New가 없고, 이 경우 이상한값이 나올수있음.</span></span><br><span class="line">p-&gt;Print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//동적할당을 받거나 캐스팅을 한 객체에 대해서 생성자호출을</span></span><br><span class="line"><span class="comment">//하고싶을때 Placement New를 해줘야 한다.</span></span><br><span class="line"><span class="comment">//물론 이건 상속 및 가상함수가 안에 포함되어 있다면 바로 뻑난다.</span></span><br></pre></td></tr></table></figure>
<h2 id="맴버-이니셜라이저"><a href="#맴버-이니셜라이저" class="headerlink" title="맴버 이니셜라이저"></a>맴버 이니셜라이저</h2><p><em>const 맴버 변수를 사용한다면 필수 사용! has-a 상속관계에서도 사용!</em></p>
<p><em>class 맴버 변수에 대해 자체적으로 사용해야된다면 포인터 변수를 따로 빼서 사용하면 훨씬 빠르다.</em></p>
<p><em>this 포인터는 너무 느림.!</em></p>
<h2 id="복사-생성자"><a href="#복사-생성자" class="headerlink" title="복사 생성자"></a>복사 생성자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 대입연산은 얇게 복사해버린다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line">C A;</span><br><span class="line">C B = A; <span class="comment">// 가있을때</span></span><br><span class="line"><span class="comment">// 완전 똑같이 복사해버려서 얇게 복사!</span></span><br><span class="line"><span class="comment">// A가 소멸자 호출을 해버리면 B는 쓰레기값이 되어버린다. -&gt; 또는 에러 핸들러로 꺼져버린다.</span></span><br><span class="line"><span class="comment">// 두번째로는 둘이 가르키는게 다 같아버려서 A가 변경되면 같이 변경된다. (포인터값이 있을때)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 이때 복사생성자를 통해 깊게 복사시켜준다.</span></span><br><span class="line">C(C&amp; CopyC)</span><br><span class="line">&#123;</span><br><span class="line">    ~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Friend-Const-Static"><a href="#Friend-Const-Static" class="headerlink" title="Friend, Const, Static"></a>Friend, Const, Static</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 이것도 오지게 짜증난다. */</span></span><br><span class="line"><span class="comment">// const 객체는 무조건 const 맴버 함수끼리만 가능 - 복습</span></span><br><span class="line"><span class="comment">// non-const,  const 함수는 오버로딩이 가능함.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Friend</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">   	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span>;</span> <span class="comment">// Girl에서 Boy 클래스를 맘대로 건들일수 있음.  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Boy Boy; <span class="comment">// 이 객체를 통해 맘대로 건든다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> Point <span class="title">PointAdd</span><span class="params">()</span></span>; <span class="comment">// 외부에서 사용가능하게 하는 메소드이다.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">PointAdd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 여기로 구현가능!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static</span></span><br><span class="line"><span class="comment">// 전역변수에 선언된 Static의 의미</span></span><br><span class="line"><span class="comment">// = 선언된 파일 내에서는 참조를 허용!</span></span><br><span class="line"><span class="comment">// 함수 내에 선언된 Static</span></span><br><span class="line"><span class="comment">// = 한번만 초기화 되고, 지역변수와 달리 변수가 살아 있다.</span></span><br><span class="line"><span class="comment">// 맴버 함수나 맴버 변수에 static</span></span><br><span class="line"><span class="comment">// = 맴버변수 -&gt; 전역변수</span></span><br><span class="line"><span class="comment">// = 맴버함수 -&gt; static 변수만 가능</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">// Static Member Variable</span></span><br><span class="line">    </span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">// 주로 스레드 함수로 사용가능하며 this 포인터 사용불가능하다.</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(x); <span class="comment">// 오직 애만 가능!</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CTest::X; <span class="comment">// 한번 선언을 해줘야 한다.</span></span><br></pre></td></tr></table></figure>
<h2 id="상속-다형성"><a href="#상속-다형성" class="headerlink" title="상속, 다형성"></a>상속, 다형성</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartimeStudent</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 Person 객체 포인터는 자식 클래스들을 받을수 있다.</span></span><br><span class="line"><span class="comment">// 이미 자기자신을 가르키는 파트가 있기때문이다.  이를 경우 Up Casting이라고 한다.</span></span><br><span class="line">Student P1 = Person; <span class="comment">//  단 만약에 Student만 존재하는 함수나 변수를 실행하면 에러 발생한다.</span></span><br><span class="line"><span class="comment">// 업캐스팅의 경우 여러 객체들을 동시처리할때 사용된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그외에 클라이언트 개발할때 다운캐스팅은 잘쓰면 엄청 좋다.</span></span><br><span class="line">Person P1 = (Person *)Student;</span><br><span class="line"><span class="comment">// CBaseObject라는 객체가 아이템, 플레이어 , 액션을 모두 담을수 있게 변수를 만든뒤 순수가상함수와 가상함수를 통해 연산을 할수 있도록 만들어둔다.</span></span><br><span class="line"><span class="comment">// 이와 같이 특정객체로 한정 지을떄 사용된다.</span></span><br></pre></td></tr></table></figure>
<h2 id="가상함수"><a href="#가상함수" class="headerlink" title="가상함수"></a>가상함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 오버라이딩 된 함수가 virtual 이라면, 오버라이딩 함수 또한 자동으로 virtual이어야만 한다.</span></span><br><span class="line"><span class="comment">// 부모클래스에서 자식클래스를 호출하고 싶을때, 가상함수가 좋은 방법이다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// virtual BB();  주석처리되어 있다면 A::BB()가 호출된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A *pa = <span class="keyword">new</span> A;</span><br><span class="line">A *pa2 = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 클래스안에 가상함수가 있다면 클래스 첫부분에 __vfptr이 생긴다.</span></span><br><span class="line"><span class="comment">// 모든 가상함수들이 테이블로써 리스트에 들어가게 된다. 하지만 이 메모리가 변조된다면, 끝장난다!!</span></span><br><span class="line"><span class="comment">// 그다가 가상함수 테이블은 공용이다 (같은 클래스 객체는 같이 사용) 이러니 문제가 미친듯이 터지게된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 문제가 생기면 일단 Pointer를 확인하고 가상함수 테이블을 확인! -&gt; 이런 문제는 찾기 너무 힘들다.</span></span><br><span class="line"><span class="comment">// 가상함수 테이블에서 주소와 함수이름이 안나온다면, 가상함수 테이블에 문제가 생긴거</span></span><br></pre></td></tr></table></figure>
<h2 id="순수-가상함수"><a href="#순수-가상함수" class="headerlink" title="순수 가상함수"></a>순수 가상함수</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인터페이스 용도로써 사용하며, (외형 전달), 상속받은 클래스가 무조건 받아서 만들어줘야 한다.</span></span><br><span class="line"><span class="comment">// Down Casting 할때 너무 좋다.</span></span><br><span class="line"><span class="comment">// 순수 가상함수로 하는 이유는, 상속받은 클래스에 대해 이것을 필수조건으로 만들어준다.</span></span><br><span class="line"><span class="comment">// 라이브러리를 만들때, 자식 클래스에 연결하고 싶을때 사용한다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BB</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">AA</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// virtual BB();  주석처리되어 있다면 컴파일 에러!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="가상-소멸자"><a href="#가상-소멸자" class="headerlink" title="가상 소멸자"></a>가상 소멸자</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up Cast 상황이든, Down Cast 상황이든, 상속관계에서 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">A *ptr = <span class="keyword">new</span> B; <span class="comment">// 을 선언했을때, </span></span><br><span class="line"><span class="comment">// 생성자는 B클래스를 했다. 만약 B클래스가 더 많은 맴버변수 및 함수를 가지고 있다면, 그 크기만큼 누수가 생긴다.</span></span><br><span class="line"><span class="comment">// 이를 해결하기 위해 가상소멸자를 사용한다.</span></span><br><span class="line"><span class="comment">// 그러면 생성된 B 클래스의 소멸자가 호출된다. -&gt; 이것또한 가상함수 테이블에 참조된다.</span></span><br></pre></td></tr></table></figure>
<h2 id="연산자-오버로딩"><a href="#연산자-오버로딩" class="headerlink" title="연산자 오버로딩"></a>연산자 오버로딩</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;p2)</span><br><span class="line"><span class="comment">//-- 단항연산자(전위)</span></span><br><span class="line">Point&amp; <span class="keyword">operator</span>++(Point&amp; ref)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point&amp; <span class="keyword">operator</span>--(Point&amp; ref)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//--단항연산자(후위)</span></span><br><span class="line"><span class="keyword">const</span> Point <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Point <span class="title">retojb</span><span class="params">(x, y)</span></span>; <span class="comment">// 사본</span></span><br><span class="line">  x++;</span><br><span class="line">  y++;</span><br><span class="line">  <span class="keyword">return</span> retojb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout과 cin, endl도 오버로딩되어 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 오버로딩</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 메모리공간의 할당</span></span><br><span class="line"><span class="comment">2. 생성자의 호출</span></span><br><span class="line"><span class="comment">3. 할당하고자 하는 자료형에 맞게 주소값반환</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *ad = <span class="keyword">new</span> <span class="keyword">char</span>[size];  <span class="comment">// 연산자 오버로딩에서 다시 new 해도 된다.</span></span><br><span class="line">  <span class="keyword">return</span> adr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--&gt; delete 문제 // 하지만 delete 함수에서 delete 함수를 선언하면 안된다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> * adr)</span>  <span class="comment">// 이 함수가 호출이 안된다.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="템플릿"><a href="#템플릿" class="headerlink" title="템플릿"></a>템플릿</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 ,14 개념까지 들어가면 대박난다.</span></span><br><span class="line"><span class="comment">// 쉽게하자면 템플릿은 모든타입에 맞춰서 클래스나 함수를 만든다.</span></span><br><span class="line"><span class="comment">// 단 템플릿은 Intelisense가 정상적으로 동작되지않고,  정적바인딩에 속한다. (컴파일에 결정된다. -&gt; 가상함수는 동적바인딩이라고 할수있다. -&gt; 런타임에 결졍된다.)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // 원래 클래스가 쓰던 데이터타입을 <span class="title">T</span>로 바꿔주면된다.</span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class">* <span class="title">function</span> <span class="title">or</span> <span class="title">class</span> <span class="title">implement</span></span></span><br><span class="line"><span class="class">*</span></span><br><span class="line"><span class="class">*/</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SimpleTemplate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function">T <span class="title">Simplefunc</span><span class="params">(<span class="keyword">const</span> T&amp; ref)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T SimpleTemplate&lt;T&gt;::Simplefunc(<span class="keyword">const</span> T&amp; ref);</span><br></pre></td></tr></table></figure>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> num2;  <span class="comment">// 수동으로 예외를 던진 케이스</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"~~~~"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 예외처리</span></span><br><span class="line"><span class="comment">// 예외발생시 catch를 통해 예외처리한다.</span></span><br><span class="line"><span class="comment">// 만약 예외발생시켯지만 아무도 catch하지않는다면 프로그래머가 선언안해도 있는 상위 catch를 통해 호출되고, 뻗는다. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack Unwinding(스택 풀기)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">throw</span> num2;</span><br><span class="line">   <span class="comment">// 예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가 전달된다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  Divide(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleFunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">      <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="keyword">char</span> expn)  <span class="comment">// 여기서 못받아서 위로 계속 올라간다.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//자료형이 일치하지 않으면 그 자료형에 맞는 catch가 나올때까지 위로 올라간다.</span></span><br><span class="line"><span class="comment">//하나의 try 영역 내에서 종류가 다른 둘 이상의 예외가 발생할 수 있기 때문에,</span></span><br><span class="line"><span class="comment">// 하나의 try 블록에 다수의 catch 블록을 추가할 수 있다.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 전달되는 예외의 명시</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ThrowFunc(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> expn)&#123;&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">char</span> expn)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThrowFunc</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span> <span class="comment">// 함수 내에서 예외 데이터가 전달될 있음을 명시</span></span></span><br></pre></td></tr></table></figure>
<h2 id="스택-풀기"><a href="#스택-풀기" class="headerlink" title="스택 풀기"></a>스택 풀기</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stack Unwinding(스택 풀기)</span></span><br><span class="line"><span class="comment">//자료형이 일치하지 않으면 그 자료형에 맞는 catch가 나올때까지 위로 올라간다. -&gt; 이를 스택풀기라고 한다.</span></span><br></pre></td></tr></table></figure>
<h2 id="C-Casting"><a href="#C-Casting" class="headerlink" title="C++ Casting"></a>C++ Casting</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이제부터 습관들려야 할 캐스팅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static_cast</span></span><br><span class="line">  강제 형변환&lt;상속관계에서는 모두 허용해준다.&gt; 이외 말도 안되는거면 그냥 컴파일단계에서 무시한다.</span><br><span class="line"><span class="keyword">const_cast</span></span><br><span class="line">  <span class="keyword">const</span> 성향 제거</span><br><span class="line"><span class="keyword">dynamic_cast</span></span><br><span class="line">  상속관계에서의 안전한 형 변환 -&gt; 런타임시에 말도 안되는 포인터면 캐스팅 X <span class="literal">nullptr</span> 리턴</span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br><span class="line">  상관없는 자료형으로의 형 변환(C Style 캐스팅)</span><br></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-19</span><i class="fa fa-tag"></i><a class="tag" href="/tags/C-C/" title="C, C++">C, C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://Mutesk.github.io/2018/03/19/Programming Language/,Mute의 개발 블로그,Programming Language(C/C++),;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/03/19/OperationSystem/" title="Operation System Content">이전 포스트</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/02/22/GameServer2/" title="Game Server Programming 3">다음 포스트</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify: || false, 
  verify:|| false, 
  app_id:'',
  app_key:'',
  placeholder:'',
  path: window.location.pathname,
  avatar:''
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>